#lang ivy1.5

################################################################################
#
# This is the abstract specification of the tilelink protocol. It defines
# the consistency reference model (reference) and abstract interface protocol
# (interface). 
################################################################################


################################################################################
#
# Global type declarations
#
################################################################################

########################################
# total order theory

module total_order(carrier) = {
    relation (T:carrier < U:carrier)
    # note: because < is polymorphic, we need to use the type here
    axiom (T:carrier < U & U < V) -> (T < V)
    axiom ~(T:carrier < T)
    axiom ~(T:carrier < U & U < T)
    axiom T:carrier < U | T = U | U < T
    # could add <= as derived relation here
}


########################################
# type of local time
type ltime
instantiate total_order(ltime)

########################################
# type of memory data
type data

########################################
# type of memory addresses
type addr

########################################
# type of ownership state
# 
# Note, this is the abstract ownership state associated with the
# interface and is not necessarily the same as the cache protocol
# state.
type ownership = { none, shrd, excl }

########################################
# describe sides of interface
type side = {client,manager}

########################################
# type of memory ops
#
# This just gives the general class of the operation for the purposes
# of determining the happens-before relation.

type otype = {read, write, amo}

########################################
# Global ID's of protocol components
type id

########################################
# type of client id
#
# ID of a client on a particular tilelink
# interface. This is not the global id.
type client_id


########################################
# structure of memory events to serialize
module memev = {
    individual type_ : otype
    individual addr_ : addr
    individual data_  : data # data for write and amo
    individual id_ : id      # process id of op
    relation serialized
    relation fused

    # TEMPORARY: no atomic ops!
    # This is because atomic ops haven't been defined yet.
    init ~serialized & ~fused & type_ ~= amo
}

################################################################################
#
# Reference specification
#
# This module defines the memory semantics. It contains a map from
# local time to memory events produced by the CPU's. The action
# "serialize" is used to serialize a memory event at the current
# physical time. This operation will fail if the happens-before
# relation prevents the operation being serialized at the current
# time.
#
################################################################################

module reference = {

    ########################################
    # memory events by local time
    # TODO: can we export this read-only?

    instantiate evs(T:ltime) : memev 

    ########################################
    # global memory state 
    # obeys partial function axiom

    function mem(A:addr) : data

    ########################################
    # Event T1 happens before T2 if it must come before T2 according
    # to the ordering constraints. This definition says that T1
    # happens before T2 if both are operations of the same CPU and if
    # T1's locally happens before T2, and if either they have the same
    # address, or one of the two is an atomic operation. The actual
    # happens-before relation is the transitive closure of
    # happens_before.

    derived happens_before(T1,T2) =
    	T1 < T2
    	& evs(T1).id_ = evs(T2).id_
    	& (evs(T1).addr_ = evs(T2).addr_ | evs(T1).type_ = amo | evs(T2).type_ = amo)
    
    # An event T1 prevents T2 if T1 happens before T2 and is not yet
    # serialized
    
    derived prevents(T1,T2) = 
        ~evs(T1).serialized & happens_before(T1,T2)

    
    ########################################
    # serialize an event lt at current global time. The "id"
    # parameter tells us what process is serializing the event.
    # 

    action serialize(lt:ltime, id_:id) = {

       # serialization must be appropriately ordered
       assert ~prevents(T1,lt);

       # serialize at current global time
       evs(lt).serialized := true;

       # update the global memory state
       local a : addr, d : data {
           a := evs(lt).addr_;
	   d := evs(lt).data_;
	   if evs(lt).type_ = read {
	      evs(lt).data_ := mem(a)
	   }
	   else {
	      if evs(lt).type_ = write {
		 mem(a) := d
	      }			
	      else {  # amo operation
		 evs(lt).data_ := mem(a);
		 mem(a) := d
	      }
	   }
       }
    }        
    delegate serialize  # this says caller is responsible for assertions

    ########################################
    # this serializes an event by combining it with another event at
    # the same location into an atomic event. For now, we assume first
    # event is a write and second event a read.

    action fuse(e1:ltime, e2:ltime, s:id) = {

       ########################################
       # pre-conditions: (TODO: check these)

       local eid:id, a:addr {
	   eid := evs(e1).id_;
	   a := evs(e1).addr_;

	   # to fuse, events must have same id and address, e1 must be a write
	   # and e2 a read with e1 < e2

	   assert evs(e2).id_ = eid;
	   assert e1 < e2 & evs(e1).type_ = write & evs(e2).type_ = read;
	   assert evs(e2).addr_ = a;

	   # This says there are no unfused events that must be ordered between e1 and e2

	   assert ~(e1 < T & T < e2 & evs(T).id_ = eid &
		    (evs(T).addr_ = a | evs(T).type_ = amo) & ~evs(T).fused);

	   # event must not already be serialized

	   assert ~evs(e2).serialized
       };

       # the effect of fusing

       evs(e2).serialized := true;
       evs(e2).fused := true;
       evs(e2).data_ := evs(e1).data_  # copy the data from write to read
    }
    delegate fuse   # this says caller is responsible for assertions
}


