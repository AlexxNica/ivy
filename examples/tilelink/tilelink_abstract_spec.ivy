#lang ivy1.3

################################################################################
#
# This is the abstract specification of the tilelink protocol. It defines
# the consistency reference model (reference) and abstract interface protocol
# (interface). It includes generic client and manager models for building
# test benches.
#
################################################################################


################################################################################
#
# Global type declarations
#
################################################################################

########################################
# total order theory

module total_order(carrier) = {
    relation (T:carrier < U:carrier)
    # note: because < is polymorphic, we need to use the type here
    axiom (T:carrier < U & U < V) -> (T < V)
    axiom ~(T:carrier < T)
    axiom ~(T:carrier < U & U < T)
    axiom T:carrier < U | T = U | U < T
    # could add <= as derived relation here
}


########################################
# type of local time
#
# Every memory operation is assigned a unique local time
#

type ltime
instantiate total_order(ltime)

########################################
# type of memory data
type data

########################################
# type of memory addresses
type addr

########################################
# type of ownership state
type ownership = { none, shrd, excl }

########################################
# describe sides of interface
type side = {client,manager}

########################################
# type of memory ops
type otype = {read, write, amo}

########################################
# id's of protocol agents
type id

########################################
# structure of memory events to serialize
#
# A memory event has operation, address, data and an id indicating
# which CPU produced the event. It also has flags indicating whether
# the even thas been serialized or fused. Initially, all events are
# unserialized.
########################################

module memev = {
    individual type_ : otype
    individual addr_ : addr
    individual data_  : data      # data for write and amo
    individual id_ : id           # process id of op
    individual serialized : bool  # has this event been serialized?
    relation fused : bool         # has this event been fused?

    init ~serialized & ~fused
}

################################################################################
#
# Reference specification
#
# This module defines the memory semantics. It contains a map from local time
# to memory events produced by the CPU's. The action "serialize" is used to
# serialize a memory event at the current physical time. This operation will
# fail if the happens-before relation prevents the operation being serialized
# at the current time.
#
#
################################################################################

module reference = {

    ########################################
    # memory events by local time

    instantiate evs(T:ltime) : memev 


    ########################################
    # global memory state 
    # 
    # This represents the state of memory after all the serialized events

    function mem(A:addr) : data

    ########################################
    # Event T1 happens before T2 if it must come before T2 according to the
    # ordering constraints. This definition says that T1 happens before T2
    # if both are operations of the same CPU and if T1's locally happens before T2,
    # and if either they have the same address, or one of the two is 
    # an atomic operation. The actual happens-before relation is the transitive
    # closure of happens_before.

    derived happens_before(T1,T2) =
    	T1 < T2
    	& evs(T1).id_ = evs(T2).id_
    	& (evs(T1).addr_ = evs(T2).addr_ | evs(T1).type_ = amo | evs(T2).type_ = amo)
    
    # An event T1 prevents T2 if T1 happens before T2 and is not yet serialized
    
    derived prevents(T1,T2) = 
        ~evs(T1).serialized & happens_before(T1,T2)

    ########################################
    # serialize an event lt at current global time. The "id" parameter
    # tells us what component is serializing the event.  Note the
    # serializing component is not usually the originating component
    # of the event.

    action serialize(lt:ltime, id_:id) = {

       # Serialization must be appropriately ordered
       # That is, every event the happens before the
       # specified event lt must already be serialized

       assert happens_before(T1,lt) -> evs(T1).serialized

       # serialize at current physical time
       evs(lt).serialized := true;

       # update the global memory state
       local a : addr, d : data {
           a := evs(lt).addr_;
	   d := evs(lt).data_;
	   if evs(lt).type_ = read {
	      evs(lt).data_ := mem(a)
	   }
	   else {
	      if evs(lt).type_ = write {
		 mem(a) := d
	      }			
	      else {  # AMO
		 # TODO: we need a specification of AMO's
		 # Probably this should be a ghost module
		 # The following is just a stand-in for the actual spec
		 evs(lt).data_ := mem(a);
		 mem(a) := d
	      }
	   }
       }
    }        
    delegate serialize

    ########################################
    # this serializes an event by combining it with another event at
    # the same location into an atomic event. For now, we assume first
    # event is a write and second event a read.
    #
    # The fuse action would be useful, for example, to a store buffer
    # that forwards read data fron buffered writes. The read a re
    # write can be fused into an atomic operation, so we guarantee the
    # are serialized consecutively.

    action fuse(e1:ltime, e2:ltime, s:id) = {

       ########################################
       # pre-conditions: (TODO: check these)

       local eid:id, a:addr {
	   eid := evs(e1).id_;
	   a := evs(e1).addr_;

	   # to fuse, events must have same id and address, e1 must be a write
	   # and e2 a read with e1 < e2

	   assert evs(e2).id_ = eid;
	   assert e1 < e2 & evs(e1).type_ = write & evs(e2).type_ = read;
	   assert evs(e2).addr_ = a;

	   # This says there are no unfused events that must be ordered between e1 and e2

	   assert ~(e1 < T & T < e2 & evs(T).id_ = eid &
		    (evs(T).addr_ = a | evs(T).type_ = amo) & ~evs(T).fused);

	   # event must not already be serialized

	   assert ~evs(e2).serialized
       };

       # the effect of fusing

       evs(e2).serialized := true;
       evs(e2).fused := true;
       evs(e2).data_ := evs(e1).data_  # copy the data from write to read
    }
    delegate fuse
}

################################################################################
#
# TileLink interface specification
#
# This describes the semantics of the interface in relation to the reference
# specification. The function "side" tells us whether a given process id is on
# the client or the manager side of this interface.
#
################################################################################

module interface(ref,clnt,mngr,side) = {

    ########################################
    # client side ownership state of address

    relation excl_p(A:addr)   # client as exclusive priv
    relation shrd_p(A:addr)   # client as shared priv
    relation dirt_p(A:addr)   # client has modified

    ########################################
    # client side events to serialize on manager side

    relation to_ser(T:ltime) 

    ########################################
    # set of cached addresses at this interface

    relation cached(A:addr)

    ########################################
    # initial state of interface. nothing owned, nothing to serialize

    init ~excl_p(A) & ~shrd_p(A) & ~dirt_p(A) & ~to_ser(T)

    
    ########################################
    # specification of release messages

    action release(a:addr, d:data, o:ownership) = {
       assert cached(a);
       assert o ~= none;
       # cannot release priviledges you don't have
       assert o = shrd -> shrd_p(a);
       assert o = excl -> excl_p(a);
       assert o = excl -> ref.mem(a) = d;  # excl release transfers correct data
       if o = excl {
           excl_p(a) := false;
	   dirt_p(a) := false      # after release the line is clean 
       } else {
           shrd_p(a) := false 
       }
    }
    mixin release before mngr.release

    ########################################
    # specification of grant messages

    action grant(a:addr, d:data, o:ownership) = {
       assert cached(a);
       assert o ~= none;
       # must grant a priviledge only once
       assert ~dirt_p(a) -> ref.mem(a) = d;   # grant has correct data if not dirty already
       if o = excl {
           assert ~excl_p(a);
           excl_p(a) := true
       } else {
           assert ~shrd_p(a);
           shrd_p(a) := true
       }
    }
    mixin grant before clnt.grant

    ########################################
    # specification of request messages
    # 
    # these model acquire/op. note they have ghost parameter "lt"
    # representing the local time of the event. a request has the
    # effect of marking an event to serialize on the manager side.
    # note the last assert says we must order the events on the
    # interface.

    action request(a:addr, d:data, mo:otype, lt:ltime) = {
       local rid:id {
           rid := ref.evs(lt).id_;
	   assert ~cached(a);
	   assert ~ref.evs(lt).serialized & ~to_ser(lt);
	   assert side(rid) = client;
	   assert ref.evs(lt).addr_ = a;
	   assert ref.evs(lt).data_ = d;
	   assert mo = ref.evs(lt).type_;
	   assert ~excl_p(a) & ~shrd_p(a); # TODO: shouldn't matter
	   assert ~(ref.happens_before(T1,lt) & ~ref.evs(T1).serialized & ~to_ser(T1));
	   to_ser(lt) := true
       }
    }
    mixin request before mngr.request

    ########################################
    # specification of request messages
    # 
    # these model grants that respond to acquire/op. they also have
    # ghost parameter "lt" representing the local time of the event. a
    # response indicates the given event has been serialized and returns
    # the result of the operation if any.

    action response(a:addr, d:data, mo:otype, lt:ltime) = {
       local rid:id {
           rid := ref.evs(lt).id_;
	   
	   assert ~cached(a);
	   assert side(rid) = client;
	   assert ref.evs(lt).addr_ = a;
	   assert ref.evs(lt).data_ = d;
	   assert mo = ref.evs(lt).type_;
	   assert ~excl_p(a) & ~shrd_p(a); # TODO: shouldn't matter
	   assert to_ser(lt);
	   assert ref.evs(lt).serialized
       }
    }
    mixin response before clnt.response

    ########################################
    # Guarantees made on "serialize" actions.
    #
    # We split this specification into two parts: a guarantee by
    # the client side and a guarantee by the manager side. This
    # because the order of the assume/guarantee argument is opposite
    # for the cleint-side and manager-side guarantees.

    # The client side promises to serialize only events for which it
    # has the appropriate ownership state.

    action serialize_client(lt:ltime, sid:id) = { 
	if side(sid) = client {  


	    local a:addr,d:data,mo:otype,eid:id {
		a := ref.evs(lt).addr_;
		d := ref.evs(lt).data_;
		mo := ref.evs(lt).type_;
		eid := ref.evs(lt).id_;
		
		assert ~ref.evs(lt).serialized;
		
		assert side(eid) = client; # client side can only serialize client side events
		
		########################################
		# client event serialized on client side. client
		# promises to serialize only with appropriate ownership
		# and in order
		
		assert mo = read -> excl_p(a) | shrd_p(a);
		assert mo = write -> excl_p(a);
		assert mo = amo -> excl_p(a);
		assert ~(ref.happens_before(T1,lt) & ~ref.evs(T1).serialized);
		if mo ~= read {
		    dirt_p(a) := true  # if modified, mark as dirty
		} 
	    }	       
	}
    }

    mixin serialize_client before ref.serialize

    # The manager side promises to serialize
    # only events that have been passed by "request".

    action serialize_manager(lt:ltime, sid:id) = { 
	if side(sid) = manager {  
	    local a:addr,d:data,mo:otype,eid:id {
		a := ref.evs(lt).addr_;
		d := ref.evs(lt).data_;
		mo := ref.evs(lt).type_;
		eid := ref.evs(lt).id_;

		assert ~ref.evs(lt).serialized;
		if side(eid) = client {

		    ########################################
		    # client event serialized on manager side. manager
		    # promises to serialize only requested events in order

		    assert to_ser(lt);
		    assert ~(to_ser(T1) & ref.happens_before(T1,lt) & ~ref.evs(T1).serialized)
		}

		########################################
		# manager event serialized on manager side. manager
		# promises to serialize only events for which client does
		# not have conflicting ownership (and in order)

		else {
		    assert mo = read -> ~excl_p(a);
		    assert mo = write -> ~excl_p(a) & ~shrd_p(a);
		    assert mo = amo -> ~excl_p(a) & ~shrd_p(a);
		    assert ~(ref.happens_before(T1,lt) & ~evs(T1).serialized)
		}
            }
	}
    }
    mixin serialize_manager before ref.serialize

    ########################################
    # Guarantees made on "fuse" actions.
    #
    # Fusing of a client side message is done on manager side iff
    # the read has been requested.

    action fuse(e1:ltime, e2:ltime, sid:id) = {
       local eid : id {
          eid := ref.evs(e2).id_;
	  assert side(sid) = manager <-> (to_ser(e2) |  side(eid) = manager)
       }
    }
    mixin fuse before ref.fuse

    ################################################################################
    #
    # Conjectured invariants of interface state
    #
    ################################################################################

    # can only be dirty if exclusive

    conjecture dirt_p(A) -> excl_p(A)

    # can only have privs if cached

    conjecture (excl_p(A) | shrd_p(A)) -> cached(A)

    # to_ser only if uncached

    conjecture ~(to_ser(T) & cached(ref.evs(T).addr_))

    # nothing to_ser if prevented by event not to_ser

    conjecture ~(ref.happens_before(T1,T2) & ~ref.evs(T1).serialized & ~to_ser(T1) & to_ser(T2))

    # only client side events are to_ser    

    conjecture to_ser(T) -> side(ref.evs(T).id_) = client

}

################################################################################
#
# Generic model of a client. This serializes arbitrary client actions, except
# the it guarantees to use only ID's from the "client" side of the interface
# as defined by its parameter "side".
#
# TODO: should be able to generate this
#
################################################################################

module generic_client(mngr,ref,side) = {
   action response(a:addr, d:data, mo:otype, lt:ltime) = {
   }
   action grant(a:addr, d:data, o:ownership) = {
   }
   action step = {
     local a:addr, d:data, mo:otype, lt:ltime, o:ownership, sid:id, lt1:ltime  {
        assume side(sid) = client;
        if * {
           call mngr.release(a, d, o)
        } else if * {
	   call mngr.request(a, d, mo, lt)
        } else if * {
	   call ref.serialize(lt,sid)
        } else {
	   call ref.fuse(lt,lt1,sid)
        }
     }
   }
}

################################################################################
#
# Generic model of a manager. This serializes arbitrary manager actions, except
# the it guarantees to use only ID's from the "manager" side of the interface
# as defined by its parameter "side".
#
# TODO: should be able to generate this
#
################################################################################

module generic_manager(clnt,ref,side) = {
   action request(a:addr, d:data, mo:otype, lt:ltime) = {
   }
   action release(a:addr, d:data, o:ownership) = {
   }
   action step = {
     local a:addr, d:data, mo:otype, lt:ltime, o:ownership, sid:id, lt1:ltime {
        assume side(sid) = manager;
        if * {
           call clnt.grant(a, d, o)
        } else if * {
	   call clnt.response(a, d, mo, lt)
        } else if * {
	   call ref.serialize(lt,sid)
        } else {
	   call ref.fuse(lt,lt1,sid)
        }
     }
   }
}

