type s.arr.t
type index.t
type elem
function s.arr.end(V0:s.arr.t) : index.t
function s.arr.value(V0:s.arr.t,V1:index.t) : elem
relation s.impl.remove_step(V0:s.arr.t,V1:elem,V2:index.t,V3:elem)
relation s.contains(V0:s.arr.t,V1:elem)
relation index.succ(V0:index.t,V1:index.t)

axiom [index.spec] index.succ(X,Z) -> (~(X < Y & Y < Z) & X < Z)
axiom [index.spec] (T:index.t < U & U < V) -> T < V
axiom [index.spec] ~(T:index.t < U & U < T)
axiom [index.spec] (T:index.t = U | T < U | U < T)
axiom [s.arr.spec] s.arr.end(X) >= 0
axiom [s.impl] (I:index.t >= 0 & index.succ(I,J)) -> s.impl.remove_step(X,E,J,Y) <-> ((s.arr.value(X,I) = Y & Y ~= E) | s.impl.remove_step(X,E,I,Y))
axiom [s.impl] I:index.t = s.arr.end(X) -> s.impl.remove_step(X,E,I,Y) <-> (Y ~= E & s.contains(X,Y))
definition [s] s.contains(X,y) = exists Z. (s.arr.value(X,Z) = y & Z < s.arr.end(X) & 0:index.t <= Z)
definition [s.impl] s.impl.remove_step(s,e,i,y) = (y ~= e & exists Z. (s.arr.value(s,Z) = y & Z < i & 0:index.t <= Z))

action s.arr.create(s:index.t,y:elem) returns(a:s.arr.t) = {
    assert 0:index.t <= s;
    assume (s.arr.end(a) = s & s.arr.value(a,X) = y)
}
action index.next(x:index.t) returns(y:index.t) = {
    assume (x < y & x < Y -> y <= Y);
    assume index.succ(x,y)
}
action ext:s.add(s:s.arr.t,e:elem) returns(s:s.arr.t) = {
    if ~s.contains(s,e) {
        local loc:0,loc:1 {
            call loc:0:= index.next(s.arr.end(s));
            call loc:1:= s.arr.resize(s, loc:0, e);
            s := loc:1
        }
    };
    assert s.contains(s,X) <-> (X = e | s.contains(old_fml:s,X))
}
action ext:s.emptyset returns(s:s.arr.t) = {
    local loc:0 {
        call loc:0:= s.arr.create(0:index.t, 0:elem);
        s := loc:0
    };
    assert ~s.contains(s,X)
}
action s.arr.resize(a:s.arr.t,s:index.t,v:elem) returns(a:s.arr.t) = {
    assume s.arr.end(a) = s;
    assume (X:index.t < s.arr.end(old_fml:a) & 0:index.t <= X) -> s.arr.value(a,X) = s.arr.value(old_fml:a,X);
    assume (X:index.t < s & s.arr.end(old_fml:a) <= X) -> s.arr.value(a,X) = v
}
action s.arr.get(a:s.arr.t,x:index.t) returns(y:elem) = {
    assert (x < s.arr.end(a) & 0:index.t <= x);
    assume s.arr.value(a,x) = y
}
action s.add(s:s.arr.t,e:elem) returns(s:s.arr.t) = {
    if ~s.contains(s,e) {
        local loc:0,loc:1 {
            call loc:0:= index.next(s.arr.end(s));
            call loc:1:= s.arr.resize(s, loc:0, e);
            s := loc:1
        }
    };
    assert s.contains(s,X) <-> (X = e | s.contains(old_fml:s,X))
}
action ext:s.remove(s:s.arr.t,e:elem) returns(res:s.arr.t) = {
    local loc:i,loc:end {
        loc:i := 0:index.t;
        local loc:0 {
            call loc:0:= s.arr.create(0:index.t, 0:elem);
            res := loc:0
        };
        loc:end := s.arr.end(s);
        while loc:i < loc:end
        invariant (0:index.t <= loc:i & loc:i <= loc:end)
        invariant s.contains(res,Y) = s.impl.remove_step(s,Y,loc:i,e)
        {
            local loc:f {
                local loc:0 {
                    call loc:0:= s.arr.get(s, loc:i);
                    loc:f := loc:0
                };
                if loc:f ~= e {
                    local loc:0 {
                        call loc:0:= s.add(res, e);
                        res := loc:0
                    }
                }
            };
            local loc:0 {
                call loc:0:= index.next(loc:i);
                loc:i := loc:0
            }
        }
    };
    assert s.contains(res,X) <-> (X ~= e & s.contains(s,X))
}
export ext:s.add
export ext:s.emptyset
export ext:s.remove
