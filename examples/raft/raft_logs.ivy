#lang ivy1.5

include theory

# This is a very abstraft model of Raft that considers only
# operations on logs and not leader election.

type log

# this is the prefix order on logs

relation (X:log < Y:log)

instantiate partial_strict_order(log,<)

# a measure function on logs, totally ordered

type weight

relation (X:log < Y:log)
instantiate total_strict_order(log,<)

individual meas(X:log) : weight

axiom (X:log < Y:log) -> (meas(X) < meas(Y))

# protocol nodes and sets of nodes

type node

type node_set
relation in(N:node,S:node_set)

# is a set a majority?

relation maj(S:node_set)

# two majorities must have a node in common
axiom maj(S1) & maj(S2) -> exists N: in(N,S1) & in(N,S2)

# abstract operations on logs

type elem

object logs = {
    
    action extend(l:log,e:elem) returns(lp:log) {
	assert l < lp 
    }

}


object proto = {
    
    individual node_logs(X:node) : log

    action extend(leader:node, dominated:node_set, e:elem) = {
	assume maj(dominated);
	assume in(X,dominated) -> (X < leader | X = leader);
	node_logs(leader) := logs.extend(node_logs(leader),e)
    }
    
    action send_log(leader:node, dominated:node_set) = {
	assume maj(dominated);
	assume in(X,dominated) -> (X < leader | X = leader);
	abs_net.send_log(leader,node_logs(leader))
    }	

    receive receive_log(dst:node, leader:node, l:log) = {
	if meas(node_logs(dst)) < meas(l:log) {
	    node_logs(dst) := l;
	    abs_net.send_ack(dst,l)
	}
    }

    # This means log L has been committed by majority S
    relation committed(L:log,S:nodes)
    init ~committed(L,S)

    # to commit a log, we mus have a majority of nodes
    # that agree with it an 

    action commit(l:log, nodes:node_set) = {
	assume maj(nodes);
	assume in(N,nodes) -> l < node_logs(N);
	assume in(N,nodes) & ~(l < node_logs(M)) -> meas(M) < meas(N)
	commited(l,nodes) := true;
    }

    conjecture commited(L,S) -> maj(S)
    conjecture commited(L,S) & in(N,nodes) -> L < node_logs(N)
    conjecture commited(L,S) & in(N,nodes) ~(L < node_logs(M)) -> meas(M) < meas(N)

}

object abs_net = {

    # this says leader N has sent log L
    sent(N:node,L:log)
    init ~(sent(N,L))

    action send_log(leader:node, l:log) = {
	sent(leader,l) := true
    }

    action send_ack(n:node, l:log) = {
	# TODO: fill this in
    }

    action receive_log(dst:node, leader:node, l:log){
	assert sent(leader,log)
    }
    execute receive_log before proto.receive_log
}
    
