#lang ivy1.3

################################################################################
#
# This is a (more) concrete specification of the tilelink protocol. It specifies
# the low-level messages with reference to the abstract spec. 
#
# The concrete model introduces Acquire and Finish messages, requester ID's,
# and other fields that indicate the address range to operate on, and so on.
#
################################################################################


include tilelink_abstract_spec

########################################
# type of TileLink ID

type tl_id


########################################
# set of addresses that can be requested

type tl_addrset

########################################
# address high and low-order bits

type tl_addrhi
type tl_addrlo

########################################
# construct adresses from high- and low-order bits

individual addr_cons(X:tl_addrhi,Y:tl_addrlo) : addr

# address constructor is an injection
axiom addr_cons(X1,Y1) = addr_cons(X2,Y2) -> X1=X2 & Y1=Y2

########################################
# semantics of address sets
# an addreset set must be a subset of a cache line

individual addrset_hi(X:tl_addrset) : tl_addrhi
relation addrset_lo(X:tl_addrset,Y:tl_addrlo)

relation addrset_contains(X:tl_addrset, Y:addr)
axiom addrset_contains(X,addr_cons(H,L)) <-> H = addrset_hi(X) & addrset_lo(X,L)

########################################
# type of message status

type tl_status = {accepted,blocked}

########################################
# structure representing Acquire message

module acq = {
    individual id_ : id               # id of requester
    individual addr_hi : tl_addrhi    # hi order bits of address
    relation words(X:tl_addrlo)       # requested words
    individual own:ownership          # what ownership type? (none=uncached)
    individual op : otype             # what operation?
    individual data_ : data           # what data, if any?
    individual ltime_ : ltime         # logical time (ghost)
}

########################################
# Heap of acquire messages

type acq_id
instantiate acqs(X:acq_id) : acq

########################################
# structure representing Grant message

module gnt = {
    individual id_ : id               # id of requester
    individual word : tl_addrlo     # low-order bits of this response
    individual own:ownership          # what ownership type? (none=uncached)
    individual data_ : data        # return value, if any
    individual ltime_ : ltime         # logical time (ghost)
}

########################################
# Heap of grant messages

type gnt_id
instantiate gnts(X:gnt_id) : gnt

########################################
# structure representing Finish message

module fns = {
    individual id_ : id             # id of requester
    individual own:ownership        # what ownership type? (none=uncached)
    relation words(X:tl_addrlo)     # requested words
    
}

########################################
# Heap of finish messages

type fns_id
instantiate fnss(X:fns_id) : fns

########################################
# structure representing Release message

module rls = {
    individual id_ : id             # id of requester
}

########################################
# Heap of release messages

type rls_id
instantiate rlss(X:rls_id) : rls


########################################
# Stub actions for mixins

module interface_stubs = {
    action release(a:addr, d:data) = {}
    action grant(a:addr, d:data, o:ownership) = {}
    action request(a:addr, d:data, mo:otype, lt:ltime) = {}
    action response(a:addr, d:data, mo:otype, lt:ltime) = {}
}


module tl_interface(ref,clnt,mngr,side) = {

    ########################################
    # whether a line is cached

    relation cached_hi(X:tl_addrhi)

    ########################################
    # time stamp generator

    individual gt : time

    action advance = {
       local ngt : time {
	   ngt := *;
	   assume gt < ngt; # TODO: without "assume?"
	   gt := ngt
       }
    }

    ########################################
    # timestamped acquire messages

    relation pend_acq(M:acq_id, T:time)
    relation pend_addr(A:tl_addrlo, T:time)   # individual grants pending

    init ~pend_acq(M,T) & ~pend_addr(A,T)

    ########################################
    # Find earliest pending request matching ID and ownership

    action match_id_own(mid:id, o:ownership) returns(req:acq_id,reqt:time) = {
#        assert exists M. exists T. pend_acq(M,T) & acqs(M).id_ = mid;
        assume pend_acq(req,reqt) & acqs(req).id_ = mid & acqs(req).own = o;
        assume T < reqt -> ~(pend_acq(M,T) & acqs(M).id_ = mid & acqs(M).own = o)
    }

    ########################################
    # Find earliest pending request matching ID, lo bits and ownership

    action match_id_lo_own(mid:id, lo:tl_addrlo, o:ownership) returns(req:acq_id,reqt:time) = {
#        assert exists M. exists T. pend_acq(M,T) & acqs(M).id_ = mid & acqs(M).words(lo);
        assume pend_acq(req,reqt) & acqs(req).id_ = mid & acqs(req).words(lo) & acqs(req).own = o;
        assume T < reqt -> ~(pend_acq(M,T) & acqs(M).id_ = mid & acqs(M).words(lo) & acqs(M).own = o)
    }


    ########################################
    # An Aquire conflict with Acquire M is a pending Acquire N at time T with
    # the same id and same ownership

    derived aconfl(M:acq_id, N:acq_id, T:time) = 
         pend_acq(N,T) & acqs(N).own = acqs(M).own & acqs(M).id_ = acqs(N).id_


    ########################################
    # specification of Acquire message

    action tl_Acquire(msg:acq_id) = {

        ########################################
	# Must request at least one word
        #    	
	assert exists W. acqs(msg).words(W);

        ########################################
        # ID of Acquire must match the reference model
	#
        
        assert acqs(msg).id_ = ref.evs(acqs(msg).ltime_).id_;

        ########################################
        # rules for multiple outstanding uncached Acquires for same id:
	#

	if acqs(msg).own = none {

	    # 1) No two atomic operations

    	    assert aconfl(msg,M,T) -> (acqs(msg).op ~= cas & acqs(M).op ~= cas);

	    # 2) Addresses must differ in low order bits

	    assert aconfl(msg,M,T) -> ~(acqs(msg).words(X) & acqs(M).words(X))

	    # 2b) Requested words must not be pending

#	    assert aconfl(msg,M,T) -> ~(acqs(msg).words(X) & acqs(M).words(X))
        }

        ########################################
        # rules for multiple outstanding cached Acquires for same id and ownership:
	#

	else {

	    # 1) No two with words in common

    	    assert aconfl(msg,M,T) -> ~(acqs(msg).words(X) & acqs(M).words(X))

        };

        ########################################
        # acquires must be cached only if in cached space
	#

	assert cached_hi(acqs(msg).addr_hi) <-> acqs(msg).own ~= none;

        ########################################
        # Update the interface state 
	#

        pend_acq(msg,gt) := true;  # mark message pending
	pend_addr(X,gt) := acqs(msg).words(X);
	call advance();       

        ########################################
        # Perform abstract opertions
	#

	if acqs(msg).own = none { # an uncached request
	    # get the address (TODO: we allow only one word in the set)
	    local word:tl_addrlo {
  	        assume acqs(msg).words(word);
		assert ~(acqs(msg).words(X) & X ~= word);

		# perform the abstract request
		call abs.request(addr_cons(acqs(msg).addr_hi,word),
                                 acqs(msg).data_,acqs(msg).op,acqs(msg).ltime_)
            }
	}
	# (cached acquires don't correspond to any abstract action) 

    }
    mixin tl_Acquire before mngr.tl_Acquire    

    ########################################
    # specification of Grant message

    action tl_Grant(msg:gnt_id) = {
        local req:acq_id, reqt:time, maddr:addr {
	
	    (req,reqt) := match_id_lo_own(gnts(msg).id_,gnts(msg).word,gnts(msg).own); # find matching request
	    assert pend_addr(gnts(msg).word,reqt);                 # the word must be pending
	    pend_addr(gnts(msg).word,reqt) := false;               # mark it no longer pending
	    maddr := addr_cons(acqs(req).addr_hi,gnts(msg).word);  # construct full address

	    if acqs(req).own ~= none {    	                   # cached: perform an abstract grant
		call abs.grant(maddr,gnts(msg).data_,acqs(req).own)
	    }
	    else {		                                   # uncached: perform an abstract response
		call abs.response(maddr,gnts(msg).data_,acqs(req).op,acqs(req).ltime_)
            }
        }
    }
    mixin tl_Grant before clnt.tl_Grant

    ########################################
    # specification of Finish message

    action tl_Finish(msg:fns_id) = {
        local req:acq_id, reqt:time, word:tl_addrlo {
	    assume fnss(msg).words(word);
	    assert ~(fnss(msg).words(X) & X ~= word); # TODO: bogus
	
	    (req,reqt) := match_id_lo_own(fnss(msg).id_,word,fnss(msg).own); # find matching request
	    assert ~pend_addr(X,reqt);         # must be no addresses pending
	    pend_acq(req,reqt) := false       # mark request completed
        }
    }   
    mixin tl_Finish before mngr.tl_Finish    

    ########################################
    # 
    # Instantiate the abstract interface specification
    #
    ########################################


    instantiate abs : interface_stubs
    instantiate interface(ref,abs,abs,side)

    ########################################
    # 
    # All or none of a line is cached
    #
    ########################################

    axiom cached(addr_cons(H,L)) <-> cached_hi(H)

}


################################################################################
#
# Generic model of a client. This performs arbitrary client actions, except
# the it guarantees to use only ID's from the "client" side of the interface
# as defined by its parameter "side".
#
# TODO: should be able to generate this
#
################################################################################

type client_action = {ca_acquire,ca_finish,ca_perform,ca_fuse}

module tl_generic_client(mngr,ref,side) = {

   action tl_Grant(msg:gnt_id) = {}

   action acquire(a:acq_id) = {
       call mngr.tl_Acquire(a)
   }

   action finish(f:fns_id) = {
       call mngr.tl_Finish(f)
   }

   action perform(lt:ltime, sid:id) = {
       assume side(sid) = client;
       call ref.perform(lt,sid)
   }

   action fuse(lt:ltime, lt1:ltime, sid:id) = {
       assume side(sid) = client;
       call ref.fuse(lt,lt1,sid)
   }

   action step = {
     local op:client_action, lt:ltime, lt1:ltime, sid:id, a:acq_id, f:fns_id {
        if * {
	   call acquire(a)
        } else if * {
	   call finish(f)
        } else if * {
	   call perform(lt,sid)
        } else {
	   call fuse(lt,lt1,sid)
        }
     }
   }
}

################################################################################
#
# Generic model of a manager. This performs arbitrary manager actions, except
# the it guarantees to use only ID's from the "manager" side of the interface
# as defined by its parameter "side".
#
# TODO: should be able to generate this
#
################################################################################

module tl_generic_manager(clnt,ref,side) = {
 
   action tl_Acquire(msg:acq_id) = {}

   action tl_Finish(msg:fns_id) = {}

   action grant(g:gnt_id) = {
      call clnt.tl_Grant(g)
   }

   action perform(lt:ltime, sid:id) = {
       assume side(sid) = manager;
       call ref.perform(lt,sid)
   }

   action fuse(lt:ltime, lt1:ltime, sid:id) = {
       assume side(sid) = manager;
       call ref.fuse(lt,lt1,sid)
   }

   action step = {
     local lt:ltime, lt1:ltime, sid:id, g:gnt_id {
        if * {
	   call grant(g)
        } else if * {
	   call perform(lt,sid)
        } else {
	   call fuse(lt,lt1,sid)
        }
     }
   }
}


# ## just for a test

# module stubs = {
#     action tl_Acquire(msg:acq_id) = {}
#     action tl_Grant(msg:gnt_id) = {}
#     action tl_Finish(msg:fns_id) = {}
# }
# instantiate sys : stubs
# instantiate ref : reference
# individual side_(I:id) : side
# instantiate intf : tl_interface(ref,sys,sys,side_)

# export sys.tl_Acquire
# export sys.tl_Grant
# export sys.tl_Finish

