#lang ivy1.3

################################################################################
#
# This is a (more) concrete specification of the tilelink protocol. It specifies
# the low-level messages with reference to the abstract spec. 
#
# The concrete model introduces Acquire and Finish messages, requester ID's,
# and other fields that indicate the address range to operate on, and so on.
#
################################################################################


################################################################################
#
# Oustanding issues:
#
#   Managers must include an up-to-date copy of the
#   data in Grants responding to Acquires upgrading permissions unless
#   they are certain that client has not been Probed since the Aquire
#   was issued.
#
# TODO: currently the spec requires all Grants to have data, even
# in the upgrade case.
#
#   The voluntary write’s data can be used to respond to the original
#   requestor with a Grant, but the transaction cannot complete until
#   the expected number of Releases have been collected by the manager.
#
# TODO: The spec may be too strict here, since it doesn't allow any grants
# to the acquiring client while there is an outstanding probe, even if a
# voluntary write has come in in the interim.
#
#
#   Managers are not obligated to accept both Acquires and merge the
#   transactions’ message flows, though they may choose to do so.
#
# TODO: In case of an upgrade, the spec requires the transactions to be merged.
################################################################################


include tilelink_abstract_spec

########################################
# type of TileLink ID

type tl_id


########################################
# set of addresses that can be requested

type tl_addrset

########################################
# address high and low-order bits

type tl_addrhi
type tl_addrlo

########################################
# construct adresses from high- and low-order bits

individual addr_cons(X:tl_addrhi,Y:tl_addrlo) : addr

# address constructor is an injection
axiom addr_cons(X1,Y1) = addr_cons(X2,Y2) -> X1=X2 & Y1=Y2

########################################
# semantics of address sets
# an addreset set must be a subset of a cache line

individual addrset_hi(X:tl_addrset) : tl_addrhi
relation addrset_lo(X:tl_addrset,Y:tl_addrlo)

relation addrset_contains(X:tl_addrset, Y:addr)
axiom addrset_contains(X,addr_cons(H,L)) <-> H = addrset_hi(X) & addrset_lo(X,L)


########################################
# structure representing Acquire message

module acq = {
    individual id_ : id               # id of requester
    individual addr_hi : tl_addrhi    # hi order bits of address
    individual word : tl_addrlo       # requested word if uncached
    individual own:ownership          # what ownership type? (none=uncached)
    individual op : otype             # what operation?
    individual data_ : data           # what data, if any?
    individual ltime_ : ltime         # logical time (ghost)
}

########################################
# Heap of acquire messages

type acq_id
instantiate acqs(X:acq_id) : acq

########################################
# structure representing Grant message

module gnt = {
    individual id_ : id               # transaction id
    individual word : tl_addrlo       # low-order bits of this response
    individual own:ownership          # what ownership type? (none = uncached)
    relation relack                   # is this an ack of a Release?
    individual data_ : data           # return value, if any
}

########################################
# Heap of grant messages

type gnt_id
instantiate gnts(X:gnt_id) : gnt

########################################
# structure representing Finish message

module fns = {
    individual id_ : id             # transaction id
}

########################################
# Heap of finish messages

type fns_id
instantiate fnss(X:fns_id) : fns

individual fns_acq(M:fns_id) : acq_id  # aux, maps finish to acquire

########################################
# structure representing Release message

module rls = {
    individual id_ : id             # id of requester
    relation voluntary              # is this a voluntary release?
    individual addr_hi : tl_addrhi  # hi order bits of address
    individual word :tl_addrlo      # word being released
    relation dirty                  # is data modified?
    individual data_ : data         # data, if dirty
}

########################################
# Heap of release messages

type rls_id
instantiate rlss(X:rls_id) : rls


########################################
# structure representing probe message

module prb = {
    individual id_ : id             # id of receiver
    individual addr_hi : tl_addrhi  # hi order bits of address
}

########################################
# Heap of probe messages

type prb_id
instantiate prbs(X:prb_id) : prb

########################################
# Stub actions for mixins

module interface_stubs = {
    action release(a:addr, d:data, o:ownership) = {}
    action grant(a:addr, d:data, o:ownership) = {}
    action request(a:addr, d:data, mo:otype, lt:ltime) = {}
    action response(a:addr, d:data, mo:otype, lt:ltime) = {}
}


module tl_interface(ref,clnt,mngr,side) = {

    ########################################
    # whether a line is cached

    relation cached_hi(X:tl_addrhi)

    ########################################
    # pending acquires
    #
    # An Acquire message is considered to be *pending* from the time
    # it is transmitted until the time its last Grant has been
    # transmitted.

    relation pend_acq(M:acq_id)

    ########################################
    # acquires accepted by manager
    #
    # An Acquire message is considered to be *accepted* from the time
    # its first Grant has been transmitted until the time its
    # Finish is transmitted.

    relation accepted(M:acq_id)

    ########################################
    # words unserved for accepted acquires
    #
    # A word of an Acquire message is considered to be *unserved* from the time
    # the Acquire is transmitted until the Grant for the corresponding word
    # is transmitted.
   
    relation unserved(M:acq_id,W:tl_addrlo)

    ########################################
    # acquires that are finished
    #
    # An Acquire message is considered finished afer its finish message
    # is transmitted

    relation finished(M:acq_id)

    ########################################
    # pending release messages
    #
    # A voluntary Release message is considered to be *pending* from
    # the time it is transmitted until the time its Grant has been
    # transmitted. As an auxliliary, we record which addresses are pending
    # release.
    # 

    relation pend_rls(M:rls_id)

    ########################################
    # requested priviledges
    #
    # Records the most recently request privs for
    # an addr. These are auxiliary.

    relation excl_r(A:tl_addrhi,W:tl_addrlo)
    relation shrd_r(A:tl_addrhi,W:tl_addrlo)
    relation none_r(A:tl_addrhi,W:tl_addrlo)


    ########################################
    # pending probe messages
    #
    # A word of a Probe message is considered to be *pending* from
    # the time the Probe is transmitted until the time the
    # corresponding involuntary Release is transmitted.
    # We track the set of lines with pending probes.
    # 

    relation pend_prb(M:prb_id, W:tl_addrlo)
    relation prb_addr(H:tl_addrhi)

    ########################################
    # granted events
    #
    # A memory event E has been granted if a corresponding
    # uncached Acquire has been granted.
    # 

    relation granted(E:ltime)

    ########################################
    # Initial condition of interface

    init ~pend_acq(M) & ~accepted(M) & ~unserved(M,W) & ~finished(M) & ~pend_rls(R)
          & ~excl_r(H,L) & ~shrd_r(H,L) & ~none_r(H,L) & ~pend_prb(P,W) & ~granted(E)

    ########################################
    # auxiliaries: map grants to acquires and releases, 
    # release to probes, finishes to acquires

    individual gnt_acq(M:gnt_id) : acq_id
    individual gnt_rls(M:gnt_id) : rls_id
    individual rls_prb(M:rls_id) : prb_id

    ########################################
    # Find the pending voluntary Release matching ID and lo bits.

    action find_release(mid:id, lo:tl_addrlo) returns(req:rls_id) = {
        assert exists M. pend_rls(M) & rlss(M).id_ = mid & rlss(M).word = lo & rlss(M).voluntary;
        assume pend_rls(req) & rlss(req).id_ = mid & rlss(req).word = lo & rlss(req).voluntary
    }

    ########################################
    # Find the pending Probe matching a Release.
    # A probe matches if same id and same hi addr

    action find_probe(msg: rls_id) returns (req:prb_id) = {
        assert exists P. pend_prb(P,rlss(msg).word) & prbs(P).id_ = rlss(msg).id_
	                     & prbs(P).addr_hi = rlss(msg).addr_hi;
        assume pend_prb(req,rlss(msg).word) & prbs(req).id_ = rlss(msg).id_
	                     & prbs(req).addr_hi = rlss(msg).addr_hi
    }
	   

    ########################################
    # An Aquire/Acquire conflict is a pending Acquire N with
    # the same id and same ownership

    derived aaconfl(M:acq_id, N:acq_id) = 
         pend_acq(N) & acqs(N).own = acqs(M).own & acqs(M).id_ = acqs(N).id_


    ########################################
    # An Acquire/Release conflict with a Release M is any Aquire N
    # with same cache line.

    derived arconfl(M:rls_id, N:acq_id) = 
         acqs(N).addr_hi = rlss(M).addr_hi


    ########################################
    # An Release/Acquire conflict is a pending Release N with
    # the same client id and same hi addr (TODO: currently is any ID).

    derived raconfl(M:acq_id, N:rls_id) = 
         pend_rls(N) & rlss(N).addr_hi = acqs(M).addr_hi 

    ########################################
    # An Release/Release conflict is a pending Release N with
    # the same id and address (TODO: currently is any ID).

    derived rrconfl(M:rls_id, N:rls_id) = 
         pend_rls(N) & rlss(N).addr_hi = rlss(M).addr_hi & rlss(N).word = rlss(M).word

    ########################################
    # An Aquire/Grant conflict is an Acquire N with
    # the same id, ownership and word (TODO: currently is any ID).

    derived agconfl(M:gnt_id,N:acq_id) =
       acqs(N).id_ = gnts(M).id_ & acqs(N).own = gnts(M).own &
           (gnts(M).own ~= none | acqs(N).word = gnts(M).word)


    ########################################
    # specification of Acquire message

    action tl_Acquire(msg:acq_id) = {

        ########################################
	# A finished acq_id is not re-used (but
	# we can have an identical Acquire with a different
	# acq_id). Having a unique acq_id for each Acquire
	# has a technical advantage in that it allows
	# us to count the oustanding Finish messages by
	# associating each with a different acq_id.

	assert ~finished(msg);

        ########################################
        # rules for uncached Acquires
	#

	if acqs(msg).own = none {

	    # (1) May not have pending acquire with same transaction ID and ownership and word.

    	    assert ~(aaconfl(msg,M) & acqs(msg).word = acqs(M).word);

	    # (2) May not have pending acquire with same transaction ID and different line.

    	    assert ~(aaconfl(msg,M) & acqs(msg).addr_hi ~= acqs(M).addr_hi);

            # (4) No two lock operations can be pending for the same
	    # client. This is required for release consistency,
	    # which would be violated by reordering lock operations.

    	    assert ~(pend_acq(M) & acqs(M).own = none
	             & ref.evs(acqs(M).ltime_).id_ = ref.evs(acqs(msg).ltime_).id_
	             & (ref.evs(acqs(M).ltime_).type_ = cas | ref.evs(acqs(msg).ltime_).type_ = cas));

	    # (5) No two operations pending on same address for the same
	    # client. This is required for release consistency,
	    # which would be violated by reordering lock operations.
	    # TODO: no client ID's yet

    	    assert ~(pend_acq(M) & acqs(M).own = none
	             & ref.evs(acqs(M).ltime_).id_ = ref.evs(acqs(msg).ltime_).id_
	             & ref.evs(acqs(M).ltime_).addr_ = ref.evs(acqs(msg).ltime_).addr_);

	    # (6) All preventing events are granted
	    # TODO: this should supercede 4 and 5
	    # TODO: this might belong in abstract spec

	    assert ref.prevents(E,acqs(msg).ltime_) -> granted(E);

            # mark the request word as unserved

	    unserved(msg,acqs(msg).word) := true

        }

        ########################################
        # rules for cached Acquires
	#

	else {

	    # (1) May not have pending acquire with same ID and ownership and with
	    # same hi addr. We can, however, have more than one ownership
	    # request in same transaction.

    	    assert ~aaconfl(msg,M);

	    # (1) May not have two cached acquires with same client and privs
	    # TODO: should allow pending with different txid

	    assert ~(acqs(msg).own ~= none & pend_acq(M) & acqs(M).own = acqs(msg).own
	             & acqs(M).addr_hi = acqs(msg).addr_hi);
	    
	    # (2) May not have a pending release with same ID and same hi addr.
	    
	    assert ~raconfl(msg,M);

	    # (3) No acquires for privs we already have

	    assert acqs(msg).own = excl -> ~excl_p(addr_cons(acqs(msg).addr_hi,W));
	    assert acqs(msg).own = shrd -> ~shrd_p(addr_cons(acqs(msg).addr_hi,W));

	    # (4) No acquires for privs already requested or being released. 
	    # This is not a rule, but rather a useful auxiliary fact.

	    assert acqs(msg).own = excl -> ~excl_r(acqs(msg).addr_hi,W) & ~none_r(acqs(msg).addr_hi,W);
	    assert acqs(msg).own = shrd -> ~shrd_r(acqs(msg).addr_hi,W) & ~none_r(acqs(msg).addr_hi,W);

            # mark the entire line as unserved

	    unserved(msg,W) := true

        };

        ########################################
        # Rule: acquires must be cached only if in cached space
	#

	assert cached_hi(acqs(msg).addr_hi) <-> acqs(msg).own ~= none;

        ########################################
        # Update the interface state 
	#

        pend_acq(msg) := true;                  # mark acquire pending

        ########################################
        # Perform abstract operations
	#

	if acqs(msg).own = none { # uncached
		call abs.request(addr_cons(acqs(msg).addr_hi,acqs(msg).word),
                                 acqs(msg).data_,acqs(msg).op,acqs(msg).ltime_)
	}
	else {
	    # (for cached, we just record the request) 
	    if acqs(msg).own  = excl {
 	       excl_r(acqs(msg).addr_hi,W) :=  true
            } else {
 	       shrd_r(acqs(msg).addr_hi,W) :=  true
            }
        } 
    }
    mixin tl_Acquire before mngr.tl_Acquire    

    ########################################
    # specification of Grant message

    action tl_Grant(msg:gnt_id) = {
        local req:acq_id, rls:rls_id, reqt:time, maddr:addr {
	
	    if gnts(msg).relack {

		########################################
		# A release ack marks the matching Release as completed

	        rls := find_release(gnts(msg).id_,gnts(msg).word);         # find matching release
		pend_rls(rls) := false;                                    # mark it completed (no Finish)

		gnt_rls(msg) := rls; # aux

	        ########################################
		# Rules for release acks:
		#
		# (1) Cannot ack a release if there is a pending Acquire that matches
		# the release (must wait for Finish).
		#

		assert ~(arconfl(rls,M) & accepted(M));

		# mark the requested release finished

		none_r(rlss(rls).addr_hi,rlss(rls).word) := false
            }
            else {	    

		########################################
		# Rule:
		#
		# Cannot grant if there are accepted acquires with a
		# difference transaction ID.
		#
		# TODO: can we grant if the transactions have
		# different clients? Should allow multiple transactions
		# with different hi addr.

		assert ~(accepted(M) & acqs(M).id_ ~= gnts(msg).id_);
	        
		########################################
		# Rule:
		# 
		# A Grant must match an accepted pending Acquire. 
		# If there is no such, a matching pending but unaccepted
		# Acquire may be accepted, but not if it matches
		# a previous accepted Acquire that is no longer pending.

		if forall M:acq_id. ~(agconfl(msg,M:acq_id) & pend_acq(M:acq_id) & accepted(M:acq_id)) {
		   assert ~(agconfl(msg,M) & accepted(M));
		   assert exists M. agconfl(msg,M) & pend_acq(M) & ~accepted(M);
		   assume agconfl(msg,req)  & pend_acq(req) & ~accepted(req);
		   accepted(req) := true
                } else {
		   assume agconfl(msg,req) & pend_acq(M) & accepted(req)
	        };
		   		 
		gnt_acq(msg) := req; # aux

	        ########################################
		# Rule:
		#
                # Cannot merge two acquires with different addresses.

		assert ~(accepted(M) & acqs(M).addr_hi ~= acqs(req).addr_hi);

	        ########################################
		# Rule:
		#
		# Cannot grant if there is a pending probe with same client id and
		# the same hi address.
		# 
		# TODO: currently ignores client ID. In case of
		# multiple clients we should be able to grant to the
		# acquiring client while the probe is pending, if we
		# have seen a voluntary release.
		#

		assert ~(pend_prb(M,W) & acqs(req).addr_hi = prbs(M).addr_hi);
		assert ~prb_addr(acqs(req).addr_hi);

	        ########################################
		# Rule: cannot grant a word already served

		assert (W = gnts(msg).word | gnts(msg).own ~= none) -> unserved(req,W);
		

	        ########################################
		# mark the word served

		unserved(req,gnts(msg).word) := false;

	        ########################################
		# if uncached, mark the event granted
		# if cached, mark the request served

		if acqs(req).own = none {
		    granted(acqs(req).ltime_) := true
		}
		else if acqs(req).own = excl {
		    excl_r(acqs(req).addr_hi,gnts(msg).word) := false
                }
		else if acqs(req).own = shrd {
		    shrd_r(acqs(req).addr_hi,gnts(msg).word) := false
                };

	        ########################################
		# if all served, mark the req not pending

		if forall W:tl_addrlo. ~unserved(req,W:tl_addrlo) {
		    pend_acq(req) := false
                };

	        ########################################
		# Abstract semantics of grant

		maddr := addr_cons(acqs(req).addr_hi,gnts(msg).word);  # construct full address
		if acqs(req).own ~= none {    	                       # cached: perform an abstract grant
		    call abs.grant(maddr,gnts(msg).data_,acqs(req).own)
		}
		else {		                                       # uncached: perform an abstract response
		    call abs.response(maddr,gnts(msg).data_,acqs(req).op,acqs(req).ltime_)
		}
            }
        }

    }
    mixin tl_Grant before clnt.tl_Grant

    ########################################
    # specification of Finish message
    #
    # A finish marks all the Acquires in a transaction as completed.

    action tl_Finish(msg:fns_id) = {
        local req:acq_id {
	
	    ########################################
	    # Rule: A finished transaction must correspond to
	    # some completed acquire.
	    	
	    req := fns_acq(msg);   # auxilary witnesses the matching acquire

	    assert (accepted(req) & ~pend_acq(req) & acqs(req).id_ = fnss(msg).id_);

	    # Finish the Acquire

	    accepted(req) := false;
	    finished(req) := true
        }
    }   
    mixin tl_Finish before mngr.tl_Finish    

    ########################################
    # specification of Release message

    action tl_Release(msg:rls_id) = {


        ########################################
        # No release with pending release with same address.
	# Because a voluntary release has to be acked before an involuntary
	# release can be issued, we can never have two matching releases
	# pending.

	assert ~rrconfl(msg,M);

        ########################################
        # Must have no requests pending when releasing.
	# This is not a rule, but rather a useful auxiliary fact.

	assert ~excl_r(rlss(msg).addr_hi,rlss(msg).word)
                 & ~shrd_r(rlss(msg).addr_hi,rlss(msg).word)
		 & ~none_r(rlss(msg).addr_hi,rlss(msg).word);

        ########################################
	# Rule: Release is dirty iff exclusive
	# TODO: allow exclusive but clean?

	assert rlss(msg).dirty <-> excl_p(addr_cons(rlss(msg).addr_hi,rlss(msg).word));

	if rlss(msg).voluntary {

	    ########################################
	    # Voluntary release. Mark as pending. 
	    #

	    pend_rls(msg) := true;
	    none_r(rlss(msg).addr_hi,rlss(msg).word) := true;

	    ########################################
	    # Rule: No voluntary release with pending acquire on same address.

	    assert ~(arconfl(msg,M) & pend_acq(M));

	    ########################################
	    # Rule: No pending voluntary release with same id and same word

	    assert ~(pend_rls(M) & rlss(M).word = rlss(msg).word & rlss(M).id_ = rlss(msg).id_)

        }
	else {
	
	    ########################################
	    # Involuntary release. Must exist a pending
	    # probe with same client id and same full eaddress.
	    #
	    # Note we *do* allow an involuntary relase with
	    # a pending Acquire.
	    # 

	    local p:prb_id {
	        p := find_probe(msg);
		rls_prb(msg) := p; # aux
		pend_prb(p,rlss(msg).word) := false;               # mark the word released
		if forall W:tl_addrlo. ~pend_prb(p,W:tl_addrlo) {
		    prb_addr(prbs(p).addr_hi) := false 		   # mark probe fully completed
                }
            }
        };

	# The abstract semantics

	local a:addr {

	    a := addr_cons(rlss(msg).addr_hi,rlss(msg).word);

	    ########################################
	    # Must have some privs on released words
            # if release is volunrary (TODO: needed?)
	    	    
	    assert rlss(msg).voluntary -> (excl_p(a) | shrd_p(a));  # these are abs state

	    # call abstract spec to release all privs

	    if excl_p(a) {
	        call abs.release(a,rlss(msg).data_,excl)
            };
	    if shrd_p(a) {
	        call abs.release(a,rlss(msg).data_,shrd)
            }

        }
    }
    mixin tl_Release before mngr.tl_Release

    ########################################
    # specification of Probe message

    action tl_Probe(msg:prb_id) = {
    
        ########################################
	# Rules for probe

	# 1) No pending probes with same transaction id and hi address
	# (TODO: currently ignores ID)

	assert ~(pend_prb(M,W) & prbs(M).addr_hi = prbs(msg).addr_hi);
	assert ~prb_addr(prbs(msg).addr_hi);

	# 2) No pending releases with same client id hi address
	# (TODO: currently ignores ID)

	assert ~(pend_rls(M) & rlss(M).addr_hi = prbs(msg).addr_hi);

        # 3) No probe if an Acquire has been accepted with same
	# hi address but is not finished.

	assert ~(accepted(M) & acqs(M).addr_hi = prbs(msg).addr_hi);

	# 5) Can only probe if client has privs on all words
	# TODO: necessary?

	assert excl_p(addr_cons(prbs(msg).addr_hi,W)) | shrd_p(addr_cons(prbs(msg).addr_hi,W));

	########################################
	# Mark the probe pending (for all words)

	pend_prb(msg,W) := true;
	prb_addr(prbs(msg).addr_hi) := true

    }
    mixin tl_Probe before clnt.tl_Probe

    ########################################
    # 
    # Instantiate the abstract interface specification
    #
    ########################################


    instantiate abs : interface_stubs
    instantiate interface(ref,abs,abs,side)

    ########################################
    # 
    # All or none of a line is cached
    #
    ########################################

    axiom cached(addr_cons(H,L)) <-> cached_hi(H)


    ################################################################################
    #
    # Conjectured invariants of the interface state
    #
    ################################################################################
    
    # A finished Acquire is neither pending nor accepted

    conjecture finished(M) -> ~pend_acq(M) & ~accepted(M)

    # No two pending or accepted cached acquires with same cache line and same privs
    # TODO: this should really be allowed

    conjecture ~((pend_acq(M1) | accepted(M1)) & (pend_acq(M2) | accepted(M2)) & M1 ~= M2 &
                 acqs(M1).own ~= none & acqs(M1).own ~= none
		 & acqs(M1).own = acqs(M2).own & acqs(M1).addr_hi = acqs(M2).addr_hi)

    # No two pending acquries that match

    conjecture ~(M1 ~= M2 & aaconfl(M1,M2) & pend_acq(M1) & pend_acq(M2) &
                 (acqs(M1).own ~= none | acqs(M1).word = acqs(M2).word))

    # No two accepted  acquires that match

    conjecture ~(accepted(M1) & accepted(M2) & M1 ~= M2 &
                 acqs(M1).own = acqs(M1).own & 
		 (acqs(M1).own ~= none | acqs(M1).word = acqs(M2).word) &
		 acqs(M1).addr_hi = acqs(M2).addr_hi)


    # If some word is served, acquire is accepted

    conjecture pend_acq(M) & ~unserved(M,W) & (acqs(M).own ~= none | W = acqs(M).word) ->
                   accepted(M)

    # While a cached acquire is pending or accepted, client has requested privs iff word is served,

#    conjecture pend_acq(M1) & acqs(M1).own = excl -> 
#                    (excl_p(addr_cons(acqs(M1).addr_hi,W)) <-> ~unserved(M1,W))
#    conjecture pend_acq(M1) & acqs(M1).own = shrd -> 
#                    (shrd_p(addr_cons(acqs(M1).addr_hi,W)) <-> ~unserved(M1,W))

    # Acquire cached status must match that of address

    conjecture (pend_acq(M1) | accepted(M1) | finished(M1)) ->
                  (acqs(M1).own ~= none <-> cached_hi(acqs(M1).addr_hi))

    # While an uncached acquire is pending, word must be to_ser and uncached
    
    conjecture pend_acq(M1) & acqs(M1).own = none ->
                  to_ser(acqs(M1).ltime_)
		  & ~cached_hi(acqs(M1).addr_hi)

    # No two pending release with same cache line and word

    conjecture ~(pend_rls(M1) & pend_rls(M2) & M1 ~= M2 &
		 rlss(M1).addr_hi = rlss(M2).addr_hi & rlss(M1).word = rlss(M2).word )

    # No two pending release with same id and word

    conjecture ~(pend_rls(M1) & pend_rls(M2) & M1 ~= M2 &
		 rlss(M1).id_ = rlss(M2).id_ & rlss(M1).word = rlss(M2).word)

    # While a release is pending, client has no privs and is cached

    conjecture pend_rls(M1) -> 
                    ~excl_p(addr_cons(rlss(M1).addr_hi,rlss(M1).word))
                    & ~shrd_p(addr_cons(rlss(M1).addr_hi,rlss(M1).word))
		    & cached_hi(rlss(M1).addr_hi)

    # No voluntary release pending while an acquire on the same address
    # is pending

    conjecture ~(pend_rls(M1) & pend_acq(M2) & rlss(M1).addr_hi = acqs(M2).addr_hi)

    # No probe pending with matching accepted acquire

    conjecture ~(pend_prb(M1,W) & accepted(M2) & prbs(M1).addr_hi = acqs(M2).addr_hi)

    # No two probes pending with same address

    conjecture ~(pend_prb(M1,W1) & pend_prb(M2,W2) & M1 ~= M2 & prbs(M1).addr_hi = prbs(M2).addr_hi)

    # Probe message with any word pending implies line is pending
    conjecture pend_prb(M,W) -> prb_addr(prbs(M).addr_hi)

    # If a release is pending, the release of the address is requested

    conjecture pend_rls(R) -> none_r(rlss(R).addr_hi,rlss(R).word)

    # If a cached acquire is pending and a word is unserved, the corresponding priv is requested

    conjecture pend_acq(M) & acqs(M).own = excl & unserved(M,W) -> excl_r(acqs(M).addr_hi,W)   
    conjecture pend_acq(M) & acqs(M).own = shrd  & unserved(M,W) -> shrd_r(acqs(M).addr_hi,W)   

    # If a cached acquire is accepted and a word is served, the corresponding priv is not requested,
    # and either the requested privs are obtained or voluntary release has been issued

    conjecture accepted(M) & acqs(M).own = excl & ~unserved(M,W) & H = acqs(M).addr_hi ->
                            ~excl_r(H,W) & (none_r(H,W) | excl_p(addr_cons(H,W)))
    conjecture accepted(M) & acqs(M).own = shrd & ~unserved(M,W) & H = acqs(M).addr_hi ->
                            ~shrd_r(H,W) & (none_r(H,W) | shrd_p(addr_cons(H,W)))

    # If a cached acquire is accepted and a word is served, we have the priv

    conjecture accepted(M) & acqs(M).own = excl -> ~unserved(M,W) -> ~excl_r(acqs(M).addr_hi,W)   
    conjecture accepted(M) & acqs(M).own = shrd -> ~unserved(M,W) -> ~shrd_r(acqs(M).addr_hi,W)       

    # Never both release and acquire request for any address

    conjecture (excl_r(H,W) | shrd_r(H,W)) -> ~none_r(H,W)

     # If an uncached Acquire has been served, its event has been serialized.

     conjecture accepted(M) & acqs(M).own = none -> ref.evs(acqs(M).ltime_).serialized

     # Anything granted is to_ser.
     
     conjecture granted(E) -> to_ser(E)

     # If anything to_ser, all prevent events are granted

     conjecture to_ser(E2) & ref.prevents(E1,E2) -> granted(E1)

}


################################################################################
#
# Generic model of a client. This performs arbitrary client actions, except
# the it guarantees to use only ID's from the "client" side of the interface
# as defined by its parameter "side".
#
# TODO: should be able to generate this
#
################################################################################

type client_action = {ca_acquire,ca_finish,ca_perform,ca_fuse}

module tl_generic_client(mngr,ref,side) = {

   action tl_Grant(msg:gnt_id) = {}

   action tl_Probe(msg:prb_id) = {}

   action acquire(a:acq_id) = {
       call mngr.tl_Acquire(a)
   }

   action finish(f:fns_id) = {
       call mngr.tl_Finish(f)
   }

   action release(f:rls_id) = {
       call mngr.tl_Release(f)
   }
   action perform(lt:ltime, sid:id) = {
       assume side(sid) = client;
       call ref.perform(lt,sid)
   }

   action fuse(lt:ltime, lt1:ltime, sid:id) = {
       assume side(sid) = client;
       call ref.fuse(lt,lt1,sid)
   }

   action step = {
     local op:client_action, lt:ltime, lt1:ltime, sid:id, a:acq_id, f:fns_id, r:rls_id {
        if * {
	   call acquire(a)
        } else if * {
	   call finish(f)
        } else if * {
	   call finish(f)
        } else if * {
	   call release(r)
        } else if * {
	   call perform(lt,sid)
        } else {
	   call fuse(lt,lt1,sid)
        }
     }
   }
}

################################################################################
#
# Generic model of a manager. This performs arbitrary manager actions, except
# the it guarantees to use only ID's from the "manager" side of the interface
# as defined by its parameter "side".
#
# TODO: should be able to generate this
#
################################################################################

module tl_generic_manager(clnt,ref,side) = {
 
   action tl_Acquire(msg:acq_id) = {}

   action tl_Finish(msg:fns_id) = {}

   action tl_Release(msg:rls_id) = {}

   action grant(g:gnt_id) = {
      call clnt.tl_Grant(g)
   }

   action probe(g:prb_id) = {
      call clnt.tl_Probe(g)
   }

   action perform(lt:ltime, sid:id) = {
       assume side(sid) = manager;
       call ref.perform(lt,sid)
   }

   action fuse(lt:ltime, lt1:ltime, sid:id) = {
       assume side(sid) = manager;
       call ref.fuse(lt,lt1,sid)
   }

   action step = {
     local lt:ltime, lt1:ltime, sid:id, g:gnt_id, p:prb_id {
        if * {
	   call grant(g)
        } else if * {
	   call probe(p)
        } else if * {
	   call perform(lt,sid)
        } else {
	   call fuse(lt,lt1,sid)
        }
     }
   }
}


# ## just for a test

# module stubs = {
#     action tl_Acquire(msg:acq_id) = {}
#     action tl_Grant(msg:gnt_id) = {}
#     action tl_Finish(msg:fns_id) = {}
# }
# instantiate sys : stubs
# instantiate ref : reference
# individual side_(I:id) : side
# instantiate intf : tl_interface(ref,sys,sys,side_)

# export sys.tl_Acquire
# export sys.tl_Grant
# export sys.tl_Finish

