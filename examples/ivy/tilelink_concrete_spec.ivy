#lang ivy1.3

################################################################################
#
# This is a (more) concrete specification of the tilelink protocol. It specifies
# the low-level messages with reference to the abstract spec. 
#
# The concrete model introduces Acquire and Finish messages, requester ID's,
# and other fields that indicate the address range to operate on, and so on.
#
################################################################################


################################################################################
#
# Oustanding issues:
#
#   Managers must include an up-to-date copy of the
#   data in Grants responding to Acquires upgrading permissions unless
#   they are certain that client has not been Probed since the Aquire
#   was issued.
#
# TODO: currently the spec requires all Grants to have data, even
# in the upgrade case.
#
#   The voluntary write’s data can be used to respond to the original
#   requestor with a Grant, but the transaction cannot complete until
#   the expected number of Releases have been collected by the manager.
#
# TODO: The spec may be too strict here, since it doesn't allow any grants
# to the acquiring client while there is an outstanding probe, even if a
# voluntary write has come in in the interim.
#
#
#   Managers are not obligated to accept both Acquires and merge the
#   transactions’ message flows, though they may choose to do so.
#
# TODO: In case of an upgrade, the spec requires the transactions to be merged.
################################################################################


include tilelink_abstract_spec

########################################
# type of TileLink ID

type tl_id


########################################
# set of addresses that can be requested

type tl_addrset

########################################
# address high and low-order bits

type tl_addrhi
type tl_addrlo

########################################
# construct adresses from high- and low-order bits

individual addr_cons(X:tl_addrhi,Y:tl_addrlo) : addr

# address constructor is an injection
axiom addr_cons(X1,Y1) = addr_cons(X2,Y2) -> X1=X2 & Y1=Y2

########################################
# semantics of address sets
# an addreset set must be a subset of a cache line

individual addrset_hi(X:tl_addrset) : tl_addrhi
relation addrset_lo(X:tl_addrset,Y:tl_addrlo)

relation addrset_contains(X:tl_addrset, Y:addr)
axiom addrset_contains(X,addr_cons(H,L)) <-> H = addrset_hi(X) & addrset_lo(X,L)


########################################
# structure representing Acquire message

module acq = {
    individual id_ : id               # id of requester
    individual addr_hi : tl_addrhi    # hi order bits of address
    individual word : tl_addrlo       # requested word if uncached
    individual own:ownership          # what ownership type? (none=uncached)
    individual op : otype             # what operation?
    individual data_ : data           # what data, if any?
    individual ltime_ : ltime         # logical time (ghost)
}

########################################
# Heap of acquire messages

type acq_id
instantiate acqs(X:acq_id) : acq

########################################
# structure representing Grant message

module gnt = {
    individual id_ : id               # transaction id
    individual word : tl_addrlo       # low-order bits of this response
    individual own:ownership          # what ownership type? (none = uncached)
    relation relack                   # is this an ack of a Release?
    individual data_ : data           # return value, if any

    individual addr_hi : tl_addrhi    # (aux) hi order bits of address
}

########################################
# Heap of grant messages

type gnt_id
instantiate gnts(X:gnt_id) : gnt

########################################
# structure representing Finish message

module fns = {
    individual id_ : id             # transaction id

    individual addr_hi : tl_addrhi    # (aux) hi order bits of acquire
    individual word : tl_addrlo       # (aux) low-order bits of acquire
    individual own:ownership          # (aux) ownership or acquire
}

########################################
# Heap of finish messages

type fns_id
instantiate fnss(X:fns_id) : fns

########################################
# structure representing Release message

module rls = {
    individual id_ : id             # id of requester
    relation voluntary              # is this a voluntary release?
    individual addr_hi : tl_addrhi  # hi order bits of address
    individual word :tl_addrlo      # word being released
    relation dirty                  # is data modified?
    individual data_ : data         # data, if dirty
}

########################################
# Heap of release messages

type rls_id
instantiate rlss(X:rls_id) : rls


########################################
# structure representing probe message

module prb = {
    individual id_ : id             # id of receiver
    individual addr_hi : tl_addrhi  # hi order bits of address
}

########################################
# Heap of probe messages

type prb_id
instantiate prbs(X:prb_id) : prb

########################################
# Stub actions for mixins

module interface_stubs = {
    action release(a:addr, d:data, o:ownership) = {}
    action grant(a:addr, d:data, o:ownership) = {}
    action request(a:addr, d:data, mo:otype, lt:ltime) = {}
    action response(a:addr, d:data, mo:otype, lt:ltime) = {}
}


module tl_interface(ref,clnt,mngr,side) = {

    ########################################
    # whether a line is cached

    relation cached_hi(X:tl_addrhi)

    ########################################
    # An Acquire has three phases: requested, accepted and finishing
    # 
    # There can be requested and accepted acquires that
    # match only if they are uncached.

    relation excl_r(A:tl_addrhi)               # there is a pending excl acquire for line
    relation shrd_r(A:tl_addrhi)               # there is a pending shrd acquire for line
    relation unc_r(A:tl_addrhi,W:tl_addrlo)    # there is a pending uncached acquire
    
    relation excl_a(A:tl_addrhi)               # there is an accepted excl acquire for line
    relation shrd_a(A:tl_addrhi)               # there is an accepted shrd acquire for line
    relation unc_a(A:tl_addrhi,W:tl_addrlo)    # there is an accepted uncached acquire
    
    relation excl_f(A:tl_addrhi)               # there is an finishing excl acquire for line
    relation shrd_f(A:tl_addrhi)               # there is an finishing shrd acquire for line
    relation unc_f(A:tl_addrhi,W:tl_addrlo)    # there is an finishing uncached acquire
    
    
    ########################################
    # pending release messages
    #
    # A voluntary Release message is considered to be *pending* from
    # the time it is transmitted until the time its Grant has been
    # transmitted. As an auxliliary, we record which addresses are pending
    # release.
    # 

    relation none_r(A:tl_addrhi,W:tl_addrlo)

    ########################################
    # pending probe messages
    #
    # A word of a Probe message is considered to be *pending* from
    # the time the Probe is transmitted until the time the
    # corresponding involuntary Release is transmitted.
    # We track the set of lines with pending probes.
    # 

    relation prb_addr(H:tl_addrhi, W:tl_addrlo)

    ########################################
    # granted events
    #
    # A memory event E has been granted if a corresponding
    # uncached Acquire has been granted.
    # 

    relation granted(E:ltime)

    ########################################
    # map from hi addresses to txids
    #
    # No two addresses can use the same txid 

    individual addr_id(A:addr) : id

    ########################################
    # Initial condition of interface

    init ~pend_rls(R)
          & ~excl_r(H) & ~shrd_r(H) & ~unc_r(H,W) 
          & ~excl_a(H,W) & ~shrd_a(H,W) & ~unc_a(H,W) 
	  & ~none_r(H,W) & ~granted(E)
	  & ~prb_addr(H,W) & ~granted(E)


    ########################################
    # Find the pending voluntary Release matching ID and lo bits.

    action find_release(mid:id, lo:tl_addrlo) returns(req:rls_id) = {
        assert exists M. pend_rls(M) & rlss(M).id_ = mid & rlss(M).word = lo & rlss(M).voluntary;
        assume pend_rls(req) & rlss(req).id_ = mid & rlss(req).word = lo & rlss(req).voluntary
    }

    ########################################
    # Find the pending Probe matching a Release.
    # A probe matches if same id and same hi addr

    action find_probe(msg: rls_id) returns (req:prb_id) = {
        assert exists P. pend_prb(P,rlss(msg).word) & prbs(P).id_ = rlss(msg).id_
	                     & prbs(P).addr_hi = rlss(msg).addr_hi;
        assume pend_prb(req,rlss(msg).word) & prbs(req).id_ = rlss(msg).id_
	                     & prbs(req).addr_hi = rlss(msg).addr_hi
    }
	   

    ########################################
    # An Aquire/Acquire conflict is a pending Acquire N with
    # the same id and same ownership

    derived aaconfl(M:acq_id, N:acq_id) = 
         pend_acq(N) & acqs(N).own = acqs(M).own & acqs(M).id_ = acqs(N).id_


    ########################################
    # An Acquire/Release conflict with a Release M is any Aquire N
    # with same cache line.

    derived arconfl(M:rls_id, N:acq_id) = 
         acqs(N).addr_hi = rlss(M).addr_hi


    ########################################
    # An Release/Acquire conflict is a pending Release N with
    # the same client id and same hi addr (TODO: currently is any ID).

    derived raconfl(M:acq_id, N:rls_id) = 
         pend_rls(N) & rlss(N).addr_hi = acqs(M).addr_hi 

    ########################################
    # An Release/Release conflict is a pending Release N with
    # the same id and address (TODO: currently is any ID).

    derived rrconfl(M:rls_id, N:rls_id) = 
         pend_rls(N) & rlss(N).addr_hi = rlss(M).addr_hi & rlss(N).word = rlss(M).word

    ########################################
    # An Aquire/Grant conflict is an Acquire N with
    # the same id, ownership and word (TODO: currently is any ID).

    derived agconfl(M:gnt_id,N:acq_id) =
       acqs(N).id_ = gnts(M).id_ & acqs(N).own = gnts(M).own &
           (gnts(M).own ~= none | acqs(N).word = gnts(M).word)


    ########################################
    # specification of Acquire message

    action tl_Acquire(msg:acq_id) = {

        local hi:tl_addrhi, lo:tl_addrlo, id_: id, ow:ownership, lt:ltime, a:addr, d:data, o:otype {

	    ow := acqs(msg).own;
	    hi := acqs(msg).addr_hi;
	    lo := acqs(msg).addr_lo;
	    id_ := acqs(msg).id_;
	    lt := acqs(msg).ltime_;
	    a := acqs(msg).addr_;
	    d := acqs(msg).data_;
	    o := acqs(msg).op;

	    ########################################
	    # rules for uncached Acquires
	    #

	    if acqs(msg).own = none {

		# (1) May not have a requested acquire with same hi address and word.

		assert ~unc_r(hi,lo);

		# (2 if any prior transactions with same hi address, txid must match

		assert (unc_r(hi,lo) | unc_a(hi,lo) -> addr_id(hi) = id_

		# (3) May not use a txid in use for a different hi addr

		assert (unc_r(H,L) | unc_a(H,L)) & H ~= hi -> addr_id(H) ~= id_


		# (4) No two lock operations can be pending for the same
		# client. This is required for release consistency,
		# which would be violated by reordering lock operations.

		assert ~(to_ser(E) & ~granted(E) & (ref.evs(E).type_ = cas | ref.evs(lt).type_ = cas));

		# (5) No two operations pending on same address for the same
		# client. This is required for release consistency,
		# which would be violated by reordering ops on same address.
		# TODO: no client ID's yet

		assert ~(to_ser(E) & ~granted(E) & ref.evs(E).addr_ = ref.evs(lt).addr_);

		# (6) All preventing events are already granted

		assert ref.prevents(E,lt) -> granted(E);

		# (7) Must have correct address, data and op

		assert addr_cons(hi,lo) = ref.evs(lt).addr_
		       & d = ref.evs(lt).data_ 
		       & o = ref.evs(lt).type_;

		# (8) Must be in uncached address space

		assert ~cached_hi(hi);

		# mark the acquire as requested

		unc_r(hi,lo) := true;

		########################################
	        # Perform abstract operation
	        #

		call abs.request(addr_cons(hi,lo),d,o,lt)

	    }

	    ########################################
	    # rules for cached Acquires
	    #

	    else {

		# (1) May not have pending acquire with same ID and ownership and with
		# same hi addr. We can, however, have more than one ownership
		# request in same transaction.

		assert ow = excl -> ~excl_r(hi) & ~excl_a(hi);
		assert ow = shrd -> ~shrd_r(hi) & ~shrd_a(hi);

		# (2 if any prior transactions with same hi address, txid must match

		assert (excl_r(hi,lo) | excl_a(hi,lo)) -> addr_id(hi) = id_;
		assert (shrd_r(hi,lo) | shrd_a(hi,lo)) -> addr_id(hi) = id_;
		
		# (3) May not use a txid in use for a different hi addr

		assert (excl_r(H | excl_a(H)) & H ~= hi -> addr_id(H) ~= id_;
		assert (shrd_r(H) | shrd_a(H)) & H ~= hi -> addr_id(H) ~= id_;
		assert none_r(H,L) & H ~= hi -> addr_id(H) ~= id_;

		# (4) May not have a pending release with same client ID and same hi addr.

		assert ~none_r(hi,W);

		# (5) No acquires for privs we already have, unless probe outstanding

		assert ow = excl & ~prb_addr(hi,W) -> ~excl_p(addr_cons(hi,W));
		assert ow = shrd & ~prb_addr(hi,W) -> ~shrd_p(addr_cons(hi,W));

		# (6) Must be in cached address space

		assert cached_hi(hi);

		# mark the acquire as requested

		if ow = excl {
		    excl_r(hi) := true;
		}
		if ow = shrd {
		    shrd_r(hi) := true;
		}
	    };

	    ########################################
	    # Associate the address and txid 

	    addr_id(hi) := id_
        }
    }
    mixin tl_Acquire before mngr.tl_Acquire    

    ########################################
    # specification of Grant message

    action tl_Grant(msg:gnt_id) = {
        local hi:tl_addrhi, lo:tl_addrlo, id_: id, reqt:time, maddr:addr, ow:ownership {
	
	    hi := gnts(msg).addr_hi;  # this field is aux
	    lo := gnts(msg).addr_lo;
	    id_ := gnts(msg).id_;
	    ow = gnts(msg).own;	    

	    if gnts(msg).relack {

		########################################
		# A release ack marks the matching Release as completed

		########################################
		# Rule: A release ack implies a pending release of the
		# corresponding word, with a matching txid

		assert none_r(hi,lo);
		assert addr_id(hi) = id_;


	        ########################################
		# Rule: Cannot ack a release if there is a pending Acquire that matches
		# the release (must wait for Finish).
		#

		assert ~excl_a(hi,W) & ~shrd_a(hi,W)

		# mark the release finished

		none_r(hi,lo) := false;
            }
            else {	    

		########################################
		# Rule:
		#
		# Cannot grant if there are accepted acquires with a
		# difference transaction ID.
		#
		# TODO: can we grant if the transactions have
		# different clients? Should allow multiple transactions
		# with different hi addr.

		assert ~(accepted(M) & acqs(M).id_ ~= gnts(msg).id_);
	        
		########################################
		# Rule:
		# 
		# A Grant must match an accepted or pending Acquire. 
		 
		assert ow = none -> (unc_r(hi.lo) | unc_a(hi,lo))
		assert ow = excl -> (excl_a(hi,lo) | excl_a(hi,lo))
		assert ow = shrd -> (shrd_a(hi,lo) | shrd_a(hi,lo))


	        ########################################
		# Rule:
		#
		# Cannot grant if there is a pending probe with same client id and
		# the same hi address.
		# 
		# TODO: currently ignores client ID. In case of
		# multiple clients we should be able to grant to the
		# acquiring client while the probe is pending, if we
		# have seen a voluntary release.
		#

		assert ~prb_addr(hi,W);

	        ########################################
		# if uncached, mark the event granted
		# if the request is not part of an accepted
		# transaction, move the request to accepted.

		if ow = none {
		    unc_r(hi,lo) := false;
		    unc_f(hi,lo) :-= true;  # for now, can't be in accepted state
		}
		else if ow = excl {
		    if ~excl_a(hi) {
		        excl_a(hi) := false;
			excl_a(hi) :-= true;
		    }
                }
		else if ow = shrd {
		    if ~shrd_a(hi) {
		        shrd_a(hi) := false;
			shrd_a(hi) :-= true;
		    }
                };

	        ########################################
		# Abstract semantics of grant

		maddr := addr_cons(hi,lo);                             # construct full address
		if gnts(msg.own ~= none {    	                       # cached: perform an abstract grant
		    call abs.grant(maddr,gnts(msg).data_,ow)

		    # if all excl privs obtained, move to finishing
		    if forall W:tl_addrlo. (ow=excl & excl_p(hi,W)) {
		        excl_a(hi) := false;
			excl_f(hi) := true
                    }

		    # if all shrd privs obtained, move to finishing
		    if forall W:tl_addrlo. (ow=shrd & shrd_p(hi,W)) {
		        shrd_a(hi) := false;
			shrd_f(hi) := true
                    }
		}

		else {		                                       # uncached: perform an abstract response
		    call abs.response(maddr,gnts(msg).data_,acqs(req).op,acqs(req).ltime_)
		    granted(acqs(req).ltime_) := true
		}
            }
        }

    }
    mixin tl_Grant before clnt.tl_Grant

    ########################################
    # specification of Finish message
    #
    # A finish marks all the Acquires in a transaction as completed.

    action tl_Finish(msg:fns_id) = {
        local hi:tl_addrhi, lo:tl_addrlo, id_: id,  ow:ownership {

	    id_ := fnss(msg).id_;
	    hi := fnss(msg).addr_hi;  # this field is aux
	    lo := fnss(msg).addr_lo;  # this field is aux
	    ow = fnss(msg).own;	  # this field is aux    
	
	    ########################################
	    # Rule: A finished transaction must correspond to
	    # some finishing acquire.
	    	
	    assert ow = none -> unc_f(hi,lo);
	    assert ow = excl -> excl_f(hi);
	    assert ow = shrd -> shrd_f(hi);

	    # Finish the Acquire

	    if ow = none {
	        unc_f(hi,lo) := false;
            }
	    if ow = excl {
	        excl_f(hi) := false;
            }
	    if ow = shrd {
	        shrd_f(hi) := false;
            }
        }
    }   
    mixin tl_Finish before mngr.tl_Finish    

    ########################################
    # specification of Release message

    action tl_Release(msg:rls_id) = {

        local hi:tl_addrhi, lo:tl_addrlo, id_: id,  ow:ownership, a:addr {

	    id_ := rlss(msg).id_;
	    hi := rlss(msg).addr_hi;  # this field is aux
	    lo := rlss(msg).addr_lo;  # this field is aux
	    ow := rlss(msg).own;	  # this field is aux    
	    a := addr_cons(hi,lo);

	    
        ########################################
	# Rule: release only cached addresses

	assert cached_hi(hi);

        ########################################
        # Rule: No release with pending release with same address.
	# Because a voluntary release has to be acked before an involuntary
	# release can be issued, we can never have two matching releases
	# pending.

	assert ~none_r(hi,lo);


        ########################################
	# Rule: Release is dirty iff exclusive
	# TODO: allow exclusive but clean release?

	assert rlss(msg).dirty <-> excl_p(a);

	if rlss(msg).voluntary {

	    ########################################
	    # (1) Must have no acquires pending when voluntarily releasing.

	    assert ~excl_r(hi) &  ~shrd_r(hi);

   	    # (2) May not use a txid in use for a different hi addr

	    assert (excl_r(H | excl_a(H)) & H ~= hi -> addr_id(H) ~= id_;
	    assert (shrd_r(H) | shrd_a(H)) & H ~= hi -> addr_id(H) ~= id_;
	    assert none_r(H,L) & H ~= hi -> addr_id(H) ~= id_;

	    # (3): Must have some privs on released words
            # if release is voluntary
	    	    
	    assert excl_p(a) | shrd_p(a);


	    ########################################
	    # Marke release as request, record txid
	    #

	    none_r(hi,lo) := true;
	    addr_id(hi) := id_
        }
	else {
	
	    ########################################
	    # Involuntary release. Must exist a pending
	    # probe with same client id and same full address.
	    #
	    # Note we *do* allow an involuntary relase with
	    # a pending Acquire.
	    # 

	    assert prb_addr(hi,lo);	    

	    prb_addr(hi,lo) := false  # mark the address probed (aux)
        };

	# The abstract semantics

	if excl_p(a) {
	    call abs.release(a,d,excl)
	};
	if shrd_p(a) {
	    call abs.release(a,d,shrd)
	}

    }
    mixin tl_Release before mngr.tl_Release

    ########################################
    # specification of Probe message

    action tl_Probe(msg:prb_id) = {
    
        local hi:tl_addrhi {

	    hi := prbs(msg).addr_hi;

	    ########################################
	    # Rules for probe


	    # (1) probe only cached addresses

	    assert cached_hi(hi);

	    # (2) No pending probes on same address and client ID
	    # (TODO: currently ignores client ID)

	    assert ~prb_addr(hi,W);

	    # 3) No probe if an Acquire with same hi address but is
	    # accepted or finishing.

	    assert ~excl_a(hi) & ~excl_f(hi) & ~shrd_a(hi) & ~ shrd_f(hi);

	    ########################################
	    # Mark the probe pending (for all words)

	    prb_addr(hi,W) := true
        }

    }
    mixin tl_Probe before clnt.tl_Probe

    ########################################
    # 
    # Instantiate the abstract interface specification
    #
    ########################################


    instantiate abs : interface_stubs
    instantiate interface(ref,abs,abs,side)

    ########################################
    # 
    # All or none of a line is cached
    #
    ########################################

    axiom cached(addr_cons(H,L)) <-> cached_hi(H)


    ################################################################################
    #
    # Conjectured invariants of the interface state
    #
    ################################################################################
    
    # A cached acquire must be in cached space, uncached in uncached space

    conjecture (excl_r(H) | excl_a(H) | excl_f(H) |
                shrd_r(H) | shrd_a(H) | shrd_f(H)) -> cached_hi(H)
    conjecture (unc_r(H,L) | unc_a(H) | unc_f(H)) -> ~cached_hi(H)

    
    # An cached acquire must be in only one phase

    conjecture ~(excl_r(H) & excl_a(H)) & ~(excl_r(H) & excl_f(H)) & ~(excl_a(H) & excl_f(H))
    conjecture ~(shrd_r(H) & shrd_a(H)) & ~(shrd_r(H) & shrd_f(H)) & ~(shrd_a(H) & shrd_f(H))

    # An uncached acquire cannot be accepted (TODO: this will change)

    conjecture ~unc_a(H,L)

    # If accepted acquire, some word must be unserved

#    conjecture excl_a(H) -> exists W. ~excl_p(addr_cons(H,W)

    # a requested voluntary release is in cached space

    conjecture none_r(H,W) -> cached_hi(H)

    # While a voluntary release is pending, to acquires are in progress
    # (but acquires can be finishing, since release can pass finish)

    conjecture none_r(H,W) -> ~excl_r(H) & ~excl_a(H) & ~shrd_r(H) & ~shrd_a(H)

    # While a release is pending, client has no privs

    conjecture none_r(H,W) & A = addr_cons(H,W) -> ~excl_p(A) & ~shrd_p(A)

    # A probe is only in cached space

    conjecture prb_addr(H,W) -> cached_hi(H)

    # No probe pending with matching accepted or finishing acquire

    conjecture prb_addr(H,W) -> ~excl_a(H) & ~excl_f(H) & ~shrd_a(H) & ~shrd_f(H)

    # If a cached acquire is requested and no voluntary release or probe outstanding,
    # we do not have the requested privs    

    conjecture excl_r(H) & ~none_r(H) & ~prb_addr(H,W) -> ~excl_p(addr_cons(H,W))
    conjecture shrd_r(H) & ~none_r(H) & ~prb_addr(H,W) -> ~shrd_p(addr_cons(H,W))

     # If an uncached Acquire has been granted, its event has been serialized.

     conjecture granted(E) -> ref.evs(E).serialized

     # Anything granted is to_ser.
     
     conjecture granted(E) -> to_ser(E)

     # If anything to_ser, all prevent events are granted

     conjecture to_ser(E2) & ref.prevents(E1,E2) -> granted(E1)

     # No two lock operations can be requested for the same
     # client. This is required for release consistency,
     # which would be violated by reordering lock operations.

     conjecture ~(to_ser(E1) & to_ser(E2) & ~granted(E1) & ~granted(E2) & E1 ~= E2 
                  ref.evs(E1).id_ = ref.evs(E2).id_
                  & (ref.evs(E1).type_ = cas | ref.evs(E1).type_ = cas))

     # (5) No two operations pending on same address for the same
     # client. This is required for release consistency,
     # which would be violated by reordering lock operations.
     # TODO: no client ID's yet

     conjecture ~(to_ser(E1) & to_ser(E2) & ~granted(E1) & ~granted(E2) & E1 ~= E2 
                  ref.evs(E1).id_ = ref.evs(E2).id_
		   & ref.evs(E1).addr_ = ref.evs(E2).addr_)


     # No two hi addresses with active transactions can have the same txid

     conjecture
        (excl_r(H1) | excl_a(H1) | excl_f(H1) | shrd_r(H1) | shrd_a(H1) | shrd_f(H1) | none_r(H1,W1))
        & (excl_r(H2) | excl_a(H2) | excl_f(H2) | shrd_r(H2) | shrd_a(H2) | shrd_f(H2) | none_r(H2,W2))
	& H1 ~= H2
	-> addr_id(H1) ~= addr_id(H2)



}


################################################################################
#
# Generic model of a client. This performs arbitrary client actions, except
# the it guarantees to use only ID's from the "client" side of the interface
# as defined by its parameter "side".
#
# TODO: should be able to generate this
#
################################################################################

type client_action = {ca_acquire,ca_finish,ca_perform,ca_fuse}

module tl_generic_client(mngr,ref,side) = {

   action tl_Grant(msg:gnt_id) = {}

   action tl_Probe(msg:prb_id) = {}

   action acquire(a:acq_id) = {
       call mngr.tl_Acquire(a)
   }

   action finish(f:fns_id) = {
       call mngr.tl_Finish(f)
   }

   action release(f:rls_id) = {
       call mngr.tl_Release(f)
   }
   action perform(lt:ltime, sid:id) = {
       assume side(sid) = client;
       call ref.perform(lt,sid)
   }

   action fuse(lt:ltime, lt1:ltime, sid:id) = {
       assume side(sid) = client;
       call ref.fuse(lt,lt1,sid)
   }

   action step = {
     local op:client_action, lt:ltime, lt1:ltime, sid:id, a:acq_id, f:fns_id, r:rls_id {
        if * {
	   call acquire(a)
        } else if * {
	   call finish(f)
        } else if * {
	   call finish(f)
        } else if * {
	   call release(r)
        } else if * {
	   call perform(lt,sid)
        } else {
	   call fuse(lt,lt1,sid)
        }
     }
   }
}

################################################################################
#
# Generic model of a manager. This performs arbitrary manager actions, except
# the it guarantees to use only ID's from the "manager" side of the interface
# as defined by its parameter "side".
#
# TODO: should be able to generate this
#
################################################################################

module tl_generic_manager(clnt,ref,side) = {
 
   action tl_Acquire(msg:acq_id) = {}

   action tl_Finish(msg:fns_id) = {}

   action tl_Release(msg:rls_id) = {}

   action grant(g:gnt_id) = {
      call clnt.tl_Grant(g)
   }

   action probe(g:prb_id) = {
      call clnt.tl_Probe(g)
   }

   action perform(lt:ltime, sid:id) = {
       assume side(sid) = manager;
       call ref.perform(lt,sid)
   }

   action fuse(lt:ltime, lt1:ltime, sid:id) = {
       assume side(sid) = manager;
       call ref.fuse(lt,lt1,sid)
   }

   action step = {
     local lt:ltime, lt1:ltime, sid:id, g:gnt_id, p:prb_id {
        if * {
	   call grant(g)
        } else if * {
	   call probe(p)
        } else if * {
	   call perform(lt,sid)
        } else {
	   call fuse(lt,lt1,sid)
        }
     }
   }
}


# ## just for a test

# module stubs = {
#     action tl_Acquire(msg:acq_id) = {}
#     action tl_Grant(msg:gnt_id) = {}
#     action tl_Finish(msg:fns_id) = {}
# }
# instantiate sys : stubs
# instantiate ref : reference
# individual side_(I:id) : side
# instantiate intf : tl_interface(ref,sys,sys,side_)

# export sys.tl_Acquire
# export sys.tl_Grant
# export sys.tl_Finish

