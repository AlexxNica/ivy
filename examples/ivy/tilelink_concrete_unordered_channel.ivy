#lang ivy1.3

################################################################################
#
# This is a model of an unordered channel using TileLink concrete interface
#
################################################################################

include tilelink_concrete_spec

########################################
# type of message ID
type msg_id

################################################################################
#
# This is the channel model. It is a bi-directional
# unordered, non-duplicating channel.
#
################################################################################


module dut(id,clnt,mngr,ref) = {

    ########################################
    # The message heap

    relation acqs(I:msg_id,M:acq_id)
    relation gnts(I:msg_id,M:gnt_id)
    relation fnss(I:msg_id,M:fns_id)
    relation rlss(I:msg_id,M:rls_id)
    relation prbs(I:msg_id,M:prb_id)

    ########################################
    # initially the channels are empty

    init ~acqs(I,A) & ~gnts(I,G) & ~fnss(I,F) & ~rlss(I,R) & ~prbs(I,P)

    ########################################
    # acquire action called by the client side
    #
    # this just enqueues a acquire message

    action tl_Acquire(msg:acq_id) = {
        local mid:msg_id {
	    assume ~acqs(mid,msg);
	    acqs(mid,msg) := true
        }
    }

    ########################################
    # grant action called by the manager side
    #
    # this just enqueues a grant message

    action tl_Grant(msg:gnt_id) = {
        local mid:msg_id {
	    assume ~gnts(mid,msg);
	    gnts(mid,msg) := true
        }
    }

    ########################################
    # finish action called by the client side
    #
    # this just enqueues a finish message

    action tl_Finish(msg:fns_id) = {
        local mid:msg_id {
	    assume ~fnss(mid,msg);
	    fnss(mid,msg) := true
        }
    }


    ########################################
    # release action called by the client side
    #
    # this just enqueues a release message

    action tl_Release(msg:rls_id) = {
        local mid:msg_id {
	    assume ~rlss(mid,msg);
	    rlss(mid,msg) := true
        }
    }


    ########################################
    # probe action called by the manager side
    #
    # this just enqueues a probe message

    action tl_Probe(msg:prb_id) = {
        local mid:msg_id {
	    assume ~prbs(mid,msg);
	    prbs(mid,msg) := true
        }
    }

    ########################################
    # internal action (step)
    #
    # pick an arbitary message and deliver it.

    
    action acquire(a:acq_id) = {
       local mid:msg_id { 
	    assume acqs(mid,a);
	    acqs(mid,a) := false; # remove from channel
	    call mngr.tl_Acquire(a)
       }
    }

    action grant(a:gnt_id) = {
       local mid:msg_id { 
            assume gnts(mid,a);
            gnts(mid,a) := false; # remove from channel
	    call clnt.tl_Grant(a)
       }
    }

    action finish(a:fns_id) = {
       local mid:msg_id { 
	   assume fnss(mid,a);
	   fnss(mid,a) := false; # remove from channel
	   call mngr.tl_Finish(a)
       }
    }

    action release(a:rls_id) = {
       local mid:msg_id { 
	   assume rlss(mid,a);
	   rlss(mid,a) := false; # remove from channel
	   call mngr.tl_Release(a)
       }
    }

    action probe(a:prb_id) = {
       local mid:msg_id { 
            assume prbs(mid,a);
            prbs(mid,a) := false; # remove from channel
	    call clnt.tl_Probe(a)
       }
    }

    action step = {
       if * {
           local a:acq_id {call acquire(a)}
       } else if * {
           local a:gnt_id {call grant(a)}
       } else if * {
     	   local a:fns_id {call finish(a)}
       } else if * {
     	   local a:rls_id {call release(a)}
       } else {
           local a:prb_id {call probe(a)}
       }
    }
}

################################################################################
#
# Verify the module using the standard testbench
#
################################################################################

include tilelink_concrete_two_port_testbench

# The channel makes these assumptions about the system configuration:

# 1) The cached address set on front and back is the same.
axiom front.cached(A) <-> back.cached(A)

################################################################################
#
# Some tests
#
################################################################################

module tests = {

    individual acq1 : acq_id, acq2 : acq_id
    individual gnt1 : gnt_id, gnt2 : gnt_id, gnt3 : gnt_id, gnt4 : gnt_id
    individual rls1 : rls_id, rls2 : rls_id
    individual fns1 : fns_id, fns2 : fns_id
    individual prb1 : prb_id, prb2 : prb_id
    individual ahi1 : tl_addrhi, ahi2 : tl_addrhi
    relation alo1(X:tl_addrlo), alo2(X:tl_addrlo)
    individual id1 : id

    action all = {
      if * {
        call c.step
      } else if * {
        call b.step 
      } else {
        call m.step
      }
    }

    # put in two acquires for same address set
    # should be possible only for different id

    action test1 = {
	assume acqs(acq1).own = none;
	call c.acquire(acq1);
	assume acqs(acq2).own = none;
	assume acqs(acq1).addr_hi = acqs(acq2).addr_hi;
	assume acqs(acq1).word = acqs(acq2).word;
	assume acqs(acq1).ltime_ < acqs(acq2).ltime_;
	call c.acquire(acq2);
	call b.acquire(acq2)
    }

    # put in two acquires for same line, same id
    # should be possible only for different words

    action test2 = {
	assume acqs(acq1).own = none;
	call c.acquire(acq1);
	assume acqs(acq2).own = none;
	assume acqs(acq1).addr_hi = acqs(acq2).addr_hi;
	assume acqs(acq1).id_ = acqs(acq2).id_;
	assume acqs(acq1).ltime_ < acqs(acq2).ltime_;
	call c.acquire(acq2);
	call b.acquire(acq2);
	call b.acquire(acq1);
	assume acqs(acq1).word = gnts(gnt1).word; 
	call m.perform(acqs(acq1).ltime_,id1);
	call m.grant(gnt1);
        call b.grant(gnt2);
	call m.perform(acqs(acq2).ltime_,id1);
	call m.grant(gnt3);
        call b.grant(gnt4)
    }

    action test3 = {
	call m.grant(gnt3)
    }

#     action test4 = {
# 	assume acqs(acq1).own = shrd;
# 	call c.acquire(acq1);
# 	call b.acquire(acq1);
# 	call m.grant(gnt1);
#         call b.grant(gnt2);
# #	call c.finish(fns1);
# 	call c.release(rls1);
# 	call b.release(rls1)
#     }

    action test4 = {
	assume acqs(acq1).own = shrd;
	assume acqs(acq2).own = excl;
	assume acqs(acq1).addr_hi = acqs(acq2).addr_hi;
	assume acqs(acq1).word = acqs(acq2).word;
	call c.acquire(acq1);
	call c.acquire(acq2);
	call b.acquire(acq2);
	call m.grant(gnt1);
        call b.grant(gnt1);
	call b.acquire(acq1);
	call m.grant(gnt2);
        call b.grant(gnt2)
;
 	call c.release(rls1)
;
 	call c.finish(fns1)
;
 	call b.release(rls1)
;
 	call b.finish(fns1)
;
 	call c.finish(fns2)
;
 	call b.finish(fns2)
;
 	call m.grant(gnt3)
;
 	call b.grant(gnt3)
;
 	call c.acquire(acq1)
;
  	call b.acquire(acq1)
#;
# 	call b.release(rls1);
# 	call b.finish(fns1);
# 	call m.grant(gnt3);
# 	call b.grant(gnt3)

    }

    # test probe crossing with upgrade acquire

    action test5 = {
	assume acqs(acq1).own = shrd;
	assume acqs(acq2).own = excl;
	assume acqs(acq1).addr_hi = acqs(acq2).addr_hi;
	assume acqs(acq1).word = acqs(acq2).word;
	call c.acquire(acq1);
	call c.acquire(acq2);
	call b.acquire(acq2);
	call m.grant(gnt1);
        call b.grant(gnt1);
	call c.finish(fns1);
	call b.finish(fns1);
	call m.probe(prb1)
;
 	call b.probe(prb1);
  	call c.release(rls1)
;
  	call b.acquire(acq1)
;
   	call b.release(rls1)
;
  	call m.grant(gnt2)
;
  	call b.grant(gnt2);
	call c.finish(fns2);
	call b.finish(fns2);
 	call m.probe(prb2);
	call b.probe(prb2);
	call c.release(rls2);
	call b.release(rls2)
# ;
# 	call b.probe(prb2)
# ;
#  	call b.grant(gnt2)
# ;
#  	call c.release(rls2)
# ;
# 	call b.release(rls2)
# ;
#  	call c.finish(fns1)
# ;
#  	call b.finish(fns1)
# ;
#  	call c.finish(fns2)
# ;
#  	call b.finish(fns2)
	
#         call b.grant(gnt2)
# ;
#  	call c.release(rls1)
# ;
#  	call c.finish(fns1)
# ;
#  	call b.release(rls1)
# ;
#  	call c.finish(fns2)
# ;
#  	call b.finish(fns2)
# ;
#  	call m.grant(gnt3)
# ;
#  	call b.grant(gnt3)
# ;
#  	call c.acquire(acq1)
# ;
#  	call b.acquire(acq1)
#;
# 	call b.release(rls1);
# 	call b.finish(fns1);
# 	call m.grant(gnt3);
# 	call b.grant(gnt3)

    }


}

instantiate t : tests
export t.all
export t.test1
export t.test2
export t.test3
export t.test4
export t.test5

export b.acquire
 export b.grant
 export b.finish
 export b.release
 export b.probe

isolate iso_t = b with ref,front,back,c,m,t


################################################################################
#
# Conjectured invariants of the channel
#
################################################################################

########################################
# Abstract interface state invariants

# If front has privs, then back also has privs. Channel doesn't dirty the line

conjecture front.excl_p(A) -> back.excl_p(A)
conjecture front.shrd_p(A) -> back.shrd_p(A)
#conjecture back.dirt_p(A) & front.excl_p(A) -> front.dirt_p(A)

# If back has request to serialize any event, then front does

conjecture back.to_ser(E) -> front.to_ser(E) 

# If an event has been granted on front, it has been transmitted to back.

conjecture front.granted(E) -> back.granted(E)

########################################
# Concrete interface state invariants

# Every Acquire pending on the back side is pending on the front.

conjecture back.pend_acq(M1) -> front.pend_acq(M1)

# Every Acquire accepted on the back side is pending or accepted or finished
# on the front side

conjecture back.accepted(M1) -> 
	   (front.pend_acq(M1) | front.accepted(M1) | front.finished(M1))

# If an uncached request is accepted on back and finished on front, and there
# is no release pending, then front has the requested privs.

conjecture back.accepted(M1) & front.finished(M1) & ~front.none_r(acqs(M1).addr_hi,W) ->
	     (acqs(M1).own = excl -> front.excl_p(addr_cons(acqs(M1).addr_hi,W)))
	     & (acqs(M1).own = shrd -> front.shrd_p(addr_cons(acqs(M1).addr_hi,W)))

# If a word of an Acquire is unserved on the back side, it is unserved
# on the front side.

conjecture back.unserved(M1,W) -> front.unserved(M1,W)

# If an Acquire is accepted on the front side, it is accepted on the
# back side.

conjecture front.accepted(M) -> back.accepted(M)

# If an Acquire is finished on the back side, it is finished on the
# front side.

conjecture back.finished(M) -> front.finished(M)

# If a cached acquire is accepted on the back, there can't be a distinct pending
# one on the front that matches.

conjecture ~(back.accepted(M1) & front.pend_acq(M2) & M1 ~= M2
	     & acqs(M1).own ~= none & acqs(M1).own = acqs(M2).own
	     & acqs(M1).addr_hi = acqs(M2).addr_hi)

# If a voluntary release is pending on the back side, it is pending on
# the front side.

conjecture back.pend_rls(M) -> front.pend_rls(M)

# If a probe is pending on the front side, it is pending on the back side.

conjecture front.pend_prb(M,W) -> back.pend_prb(M,W)

# requested privs on back imply requested privs on front

conjecture (back.excl_r(H,W) -> front.excl_r(H,W))
	   & (back.shrd_r(H,W) -> front.shrd_r(H,W))
	   & (back.none_r(H,W) -> front.none_r(H,W))

# if privs on back but not front, and nothing requested on front, then
# there must be an old probe or voluntary release pending

conjecture A = addr_cons(H,W) & ~front.excl_p(A) & ~front.excl_r(H,W) & back.excl_p(A)
	   -> front.none_r(H,W) | back.prb_addr(H,W)
conjecture A = addr_cons(H,W) & ~front.shrd_p(A) & ~front.shrd_r(H,W) & back.shrd_p(A)
	   -> front.none_r(H,W) | back.prb_addr(H,W)

# if dirty on back but not front, then there must be an old probe or
# voluntary release pending

conjecture A = addr_cons(H,W) & ~front.dirt_p(A) & back.dirt_p(A)
	   -> front.none_r(H,W) | back.prb_addr(H,W)

# if an aquire is in the channel an there is no pending probe, then back does not have the requested privs

conjecture front.pend_acq(M1) & ~back.pend_acq(M1) & ~back.accepted(M1)
	       & ~back.prb_addr(acqs(M1).addr_hi,W) & A = addr_cons(acqs(M1).addr_hi,W) ->
	     (acqs(M1).own = excl -> ~back.excl_p(A)) & (acqs(M1).own = shrd -> ~back.shrd_p(A)) 

# probe on front implies probe on back

conjecture front.prb_addr(H,W) -> back.prb_addr(H,W)

# if an uncached acquire is pending on the front but not the back, it is not to_ser on the back and
# is not serialized

conjecture front.pend_acq(M) & ~back.pend_acq(M) & ~back.accepted(M) & acqs(M).own = none ->
                 ~back.to_ser(acqs(M).ltime_) & ~ref.evs(acqs(M).ltime_).serialized

# if probed on the front and no release pending and no privs, then back has no privs

conjecture ~front.none_r(H,W) & A = addr_cons(H,W) 
	   & (~front.excl_r(H,W) & ~front.shrd_r(H,W) & ~back.prb_addr(H,W) | (b.prbs(I1,M1) & prbs(M1).addr_hi = H) | front.prb_addr(H,W))
           ->
	     (~front.excl_p(A) & ~front.shrd_p(A) -> ~back.excl_p(A) & ~back.shrd_p(A))

# if no privs requested, then front has either all privs of back or no privs

conjecture ~front.excl_r(H,W) & ~front.shrd_r(H,W) & A = addr_cons(H,W) ->
	   (~front.excl_p(A) & ~front.shrd_p(A) |
	    (back.excl_p(A) -> front.excl_p(A)) & (back.shrd_p(A) -> front.shrd_p(A)))

########################################
# Channel content invariants.
  
####################
# Acquires

# Every Acquire message in the channel is pending on the front side
# and not pending or accepted on the back side. Moreover, all requested words are unserved.

conjecture b.acqs(I1,M1) -> front.pend_acq(M1) & ~back.pend_acq(M1) &
	                    ~back.accepted(M1) &
	                    ((W = acqs(M1).word | acqs(M1).own ~= none) -> front.unserved(M1,W))

# An uncache Acquire in the channel indicates privs are not already
# requested on back, or there is a pending probe or voluntary request
# (from an earlier transaction)

conjecture b.acqs(I1,M1) & acqs(M1).own = excl & H = acqs(M1).addr_hi & back.excl_r(H,W)
	   -> false # back.prb_addr(H,W)
conjecture b.acqs(I1,M1) & acqs(M1).own = shrd & H = acqs(M1).addr_hi & back.shrd_r(H,W)
	   -> false # back.prb_addr(H,W)

# conjecture b.acqs(I1,M1) & acqs(M1).own = excl & H = acqs(M1).addr_hi & back.excl_r(H,W)
#	   -> front.none_r(H,W) | back.prb_addr(H,W)
# conjecture b.acqs(I1,M1) & acqs(M1).own = shrd & H = acqs(M1).addr_hi & back.shrd_r(H,W)
#	   -> front.none_r(H,W) | back.prb_addr(H,W)


# Channel can contain a given Acquire message at most once

conjecture b.acqs(I1,M) & b.acqs(I2,M) -> I1 = I2

####################
# Grants

# Every non-relack grant in the channel matches an acquire, which must
# be pending an front and accepted on back. Specified word must be
# served on back side and unserved on front side.

conjecture b.gnts(I1,M1) & M2 = back.gnt_acq(M1) & ~gnts(M1).relack -> 
	       gnts(M1).id_ = acqs(M2).id_
	       & gnts(M1).own = acqs(M2).own
	       & (gnts(M1).own = none -> gnts(M1).word = acqs(M2).word)
	       & front.pend_acq(M2) & back.accepted(M2)
	       & ~back.unserved(M2,gnts(M1).word)
	       & front.unserved(M2,gnts(M1).word)
#	       & (gnts(M1).own = none -> back.granted(acqs(M2).ltime_))

# A non-relack grant in the channel can only match one accepted Acquire at the front

conjecture b.gnts(I1,M1) & ~gnts(M1).relack
	       & gnts(M1).id_ = acqs(M2).id_
	       & gnts(M1).own = acqs(M2).own
	       & (gnts(M1).own = none -> gnts(M1).word = acqs(M2).word)
	       & (W = gnts(M1).word | gnts(M1).own ~= none )
	       & front.accepted(M2) -> M2 = back.gnt_acq(M1)

# A non-relack grant in the channel cannot match a an accepted Acquire at the front
# with a different transaction ID.

conjecture  b.gnts(I1,M1) & ~gnts(M1).relack & M2 ~= back.gnt_acq(M1) & back.accepted(M2) ->
	       acqs(M2).id_ = gnts(M1).id_ & acqs(M2).addr_hi = acqs(back.gnt_acq(M1)).addr_hi


# non-relack cached grant messages have correct data, if not dirtied by client

conjecture b.gnts(I1,M1) & M2 = back.gnt_acq(M1) & ~gnts(M1).relack
	   & A = addr_cons(acqs(M2).addr_hi,gnts(M1).word)
	   & acqs(M2).own ~= none & ~front.dirt_p(A) & ~back.dirt_p(A) ->
                   gnts(M1).data_ = ref.mem(A)

# non-relack uncached grant messages have correct data

conjecture b.gnts(I1,M1) & M2 = back.gnt_acq(M1) & ~gnts(M1).relack & acqs(M2).own = none ->
               gnts(M1).data_ = ref.evs(acqs(M2).ltime_).data_

# no two grants in channel for same word of same acquire

conjecture ~(b.gnts(I1,M1) & b.gnts(I2,M2) & ~gnts(M1).relack & ~gnts(M2).relack & M1 ~= M2
	    & back.gnt_acq(M1) = back.gnt_acq(M2)
            & gnts(M1).word = gnts(M2).word)

# Every relack grant in the channel matches an pending voluntary
# release, which must be pending at the front. No matching acquire can
# be accepted at back. No matching release can be pending at the back.
# There can be no privs on the back

conjecture b.gnts(I1,M1) & M2 = back.gnt_rls(M1) & gnts(M1).relack -> 
	       rlss(M2).voluntary
   	       & gnts(M1).id_ = rlss(M2).id_
   	       & gnts(M1).word = rlss(M2).word
	       & front.pend_rls(M2)
	       & ~(back.accepted(M3) & acqs(M3).addr_hi = rlss(M2).addr_hi)
	       & ~back.none_r(rlss(M2).addr_hi,rlss(M2).word)
	       & ~back.excl_p(addr_cons(rlss(M2).addr_hi,rlss(M2).word))
	       & ~back.shrd_p(addr_cons(rlss(M2).addr_hi,rlss(M2).word))

conjecture b.gnts(I1,M1) & gnts(M1).relack
	       & rlss(M2).voluntary
   	       & gnts(M1).id_ = rlss(M2).id_
   	       & gnts(M1).word = rlss(M2).word
               -> ~back.pend_rls(M2)

# no two relacks in channel for same release

conjecture ~(b.gnts(I1,M1) & b.gnts(I2,M2) & gnts(M1).relack & gnts(M2).relack & M1 ~= M2
	    & back.gnt_rls(M1) = back.gnt_rls(M2))

# No grant in the channel if there is a matching Acquire accepted on the back. TODO: ???


# Channel can contain a given Grant message at most once

conjecture b.gnts(I1,M) & b.gnts(I2,M) -> I1 = I2

####################
# Releases

# Every voluntary release message in the channel is pending on the front
# side and not pending on the back side

conjecture b.rlss(I1,M1) & rlss(M1).voluntary ->
                  front.pend_rls(M1) & ~back.pend_rls(M1)


# no other matching releases are pending the back side

conjecture ~(b.rlss(I1,M1) & M1 ~= M2  & back.pend_rls(M2)
               & rlss(M1).addr_hi = rlss(M2).addr_hi & rlss(M1).word = rlss(M2).word)
conjecture b.rlss(I1,M1) -> ~back.none_r(rlss(M1).addr_hi,rlss(M1).word)

# Every involuntary release message in the channel matches a probe
# that is pending on back side and not pending on font side, and there
# are no privs on the front side.

conjecture b.rlss(I1,M1) & ~rlss(M1).voluntary & M2 = front.rls_prb(M1) -> 
	   rlss(M1).addr_hi = prbs(M2).addr_hi
	   & back.pend_prb(M2,rlss(M1).word) & ~front.pend_prb(M2,rlss(M1).word)
	   & ~front.excl_p(addr_cons(rlss(M1).addr_hi,rlss(M1).word))
	   & ~front.shrd_p(addr_cons(rlss(M1).addr_hi,rlss(M1).word))
	   & ~front.prb_addr(rlss(M1).addr_hi,rlss(M1).word)

# a release message means some privs on back side

conjecture b.rlss(I1,M1) & rlss(M1).voluntary & A = addr_cons(rlss(M1).addr_hi,rlss(M1).word) ->
	      (back.excl_p(A) | back.shrd_p(A))

# no two matching release messages can be in channel

conjecture ~(b.rlss(I1,M1) & b.rlss(I2,M2) & M1 ~= M2
	     & rlss(M1).addr_hi = rlss(M2).addr_hi
	     & rlss(M1).word = rlss(M2).word)

# a dirty release message in channel means excl privs on back side, and vice-versa

conjecture b.rlss(I1,M1) & A = addr_cons(rlss(M1).addr_hi,rlss(M1).word) ->
	   (rlss(M1).dirty <-> back.excl_p(A))

# dirty release messages have correct data

conjecture b.rlss(I1,M1) & A = addr_cons(rlss(M1).addr_hi,rlss(M1).word) &
	   rlss(M1).dirty -> back.excl_p(A) -> 
              rlss(M1).data_ = ref.mem(A)

# Channel can contain a given Release message at most once

conjecture b.rlss(I1,M) & b.rlss(I2,M) -> I1 = I2

####################
# Probes

# Every Probe message in the channel is pending on the back side and not
# pending on the front side

conjecture b.prbs(I1,M1) -> back.pend_prb(M1,W) & ~front.pend_prb(M1,W)
                & ~front.prb_addr(prbs(M1).addr_hi,W)

# Can't be two matching probes in channel

conjecture ~(b.prbs(I1,M1) & b.prbs(I2,M2) & M1 ~= M2
	     & prbs(M1).addr_hi = prbs(M2).addr_hi)

# Can't be matching probe and involuntary release in channel

conjecture ~(b.prbs(I1,M1) & b.rlss(I2,M2)
	     & ~rlss(M2).voluntary
	     & prbs(M1).addr_hi = rlss(M2).addr_hi)

# Channel can contain a given Probe message at most once

conjecture b.prbs(I1,M) & b.prbs(I2,M) -> I1 = I2

####################
# Finishes

# Every Finish message in the channel matches an acquire that is finished
# on the front side and accepted but not finished on the back side.

conjecture b.fnss(I1,M1) & M2 = fns_acq(M1) -> 
	     fnss(M1).id_ = acqs(M2).id_
	     & front.finished(M2) & back.accepted(M2) & ~back.finished(M2)

# Can't be two finishes for same acquire in channel

conjecture ~(b.fnss(I1,M1) & b.fnss(I2,M2) & M1 ~= M2
	     & fns_acq(M1) = fns_acq(M2))

# Channel can contain a given Finish message at most once

conjecture b.fnss(I1,M) & b.fnss(I2,M) -> I1 = I2


