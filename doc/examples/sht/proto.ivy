#lang ivy1.6

################################################################################
# 
# This is the top-level server description
#
# "ref" is the reference object
# "me" is the server's id
# net is the network

include table
include delmap

module sht_protocol(me,ref,trans,id,key,data,shard) = {

    action set(k:key.t,d:data) returns(ok:bool)
    action get(k:key.t) returns(ok:bool)
    action answer(k:key.t,d:data,lt:ref.txid)
    action delegate_(dst:id, lo:key.iter.t, hi:key.iter.t)  returns(ok:bool)

    object req = {
	type t = struct {
	    src : id,
	    rkey : key.t,
	    rtype : ref.otype,
	    rdata : data,
	    ltime : ref.txid
	}
    }

    object spec = {
	before delegate_ {
	    assert dst ~= me;
	    assert lo <= hi;
	    assert key.iter.between(lo,K,hi) -> impl.dm.map(K,me)
	}
	before trans.send_reply(dst:id, rq:req.t) {
	    assert ref.data_(req.ltime(rq)) = req.rdata(rq)
	}
	before answer {
	    assert ref.data_(lt) = d
	}
    }


    object impl = {

	# The server's hash table

	instance hash : hash_table(key,data,shard)

	# The server's delegation map

	instance dm : delegation_map(key,id)

	# Handle a request from user or from network
	
	action handle_request(rq:req.t) returns(ok:bool) = {
	    local src:id, k:key.t, op:ref.otype, d:data, lt:ref.txid, ow:id {
		src := req.src(rq);
		k := req.rkey(rq);
		op := req.rtype(rq);
		d := req.rdata(rq);
		lt := req.ltime(rq);
		ow := dm.get(k);
		if ow = me {
		    call ref.commit(lt);  # this is ghost!
		    if op = ref.read {
			req.rdata(rq) := hash.get(k)
		    }
		    else {
			call hash.set(k,d)
		    };
		    ok := trans.send_reply(me, src, rq)
		} else {
		    ok := trans.send_request(me, ow, rq)  # forward request
		}
	    }
	}

	action generate_request(rq:req.t) returns(ok:bool) = {
	    req.ltime(rq) := ref.begin(me,req.rtype(rq),req.rkey(rq),req.rdata(rq));
	    ok := handle_request(rq)
	}

	implement set {
	    local rq:req.t {
		req.src(rq) := me;
		req.rkey(rq) := k;
		req.rtype(rq) := ref.write;
		req.rdata(rq) := d;
		ok := generate_request(rq)
	    }
	}

	implement get {
	    local rq:req.t {
		req.src(rq) := me;
		req.rkey(rq) := k;
		req.rtype(rq) := ref.read;
		ok := generate_request(rq)
	    }
	}

	implement trans.recv_request(rq:req.t) {
	    local ok : bool {
		ok := handle_request(rq)
	    }
	}

	implement trans.recv_reply(rq:req.t) {
	    call answer(req.rkey(rq),req.rdata(rq),req.ltime(rq))
	}

	implement delegate_ {
	    call dm.set(lo,hi,dst);
	    ok := trans.send_delegate(me,dst,hash.extract_(lo,hi))
	}

	implement trans.recv_delegate(s:shard.t) {
	    if shard.valid(s) {  # ignore mal-formed messages
		call dm.set(shard.lo(s),shard.hi(s),me);
		call hash.incorporate(s)
	    }
	}


	# If I own this key, then my hash table data matches the reference
	conjecture p.impl.dm(me).map(K,me) -> hash.hash(K) = ref.map(K)

	# If I own this key, then no one else does
	conjecture p.impl.dm(me).map(K,me) & X ~= me -> ~p.impl.dm(X).map(K,X)

	# If I own this key, then no delegated shard does
	conjecture p.impl.dm(me).map(K,me) -> ~(trans.delegated(X,S) & key.iter.between(shard.lo(S),K,shard.hi(S)))

	# No two delegated shards have keys in common
	conjecture trans.delegated(X,S) & key.iter.between(shard.lo(S),K,shard.hi(S))
		   & trans.delegated(X1,S1) & key.iter.between(shard.lo(S1),K,shard.hi(S1))
		   -> X = X1 & S = S1

	# Forwarded requests have correct operations relative to the reference

	conjecture trans.requested(D,R) & L = req.ltime(R)->
		   (req.rkey(R) = ref.key_(L) &
		    req.rtype(R) = ref.type_(L) &
		    (req.rtype(R) = ref.write -> req.rdata(R) = ref.data_(L)))

	# Forwarded replies have correct operations relative to the reference

	conjecture trans.replied(D,R) & L = req.ltime(R)->
		   (req.rkey(R) = ref.key_(L) &
		    req.rtype(R) = ref.type_(L) &
		    req.rdata(R) = ref.data_(L))

	# All forwarded requests have been generated but not committed

	conjecture trans.requested(D,R) -> ref.generated(req.ltime(R)) & ~ref.committed(req.ltime(R))

	# All forwarded replies have been generated and committed

	conjecture trans.replied(D,R) -> ref.generated(req.ltime(R)) & ref.committed(req.ltime(R))

	# No two forwarded requests with the same ltime

	conjecture trans.requested(D1,R1) & trans.requested(D2,R2) & req.ltime(R1) = req.ltime(R2)
		   -> D1 = D2 & R1 = R2

	# No two forwarded replies with the same ltime

	conjecture trans.replied(D1,R1) & trans.replied(D2,R2) & req.ltime(R1) = req.ltime(R2)
		   -> D1 = D2 & R1 = R2

	# Delegated shards have correct data

	conjecture trans.delegated(X,S) & key.iter.between(shard.lo(S),K,shard.hi(S)) -> shard.value(S,K) = ref.map(K)

	# Everything committed has been generated

	conjecture ref.committed(T) -> ref.generated(T)
    }
}

